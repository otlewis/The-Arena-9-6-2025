import 'dart:async';
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart' as lk;
import 'package:appwrite/appwrite.dart';
import 'package:appwrite/models.dart' as models;
import '../services/open_discussion_service.dart';
import '../services/appwrite_service.dart';
import '../services/participant_service.dart';
import '../services/livekit_connection_manager.dart';
import '../services/participant_promotion_service.dart';
import '../core/error_handling/error_boundary.dart';
import '../models/timer_state.dart' as timer_models;
import '../widgets/user_avatar.dart';
import '../widgets/room_chat_panel.dart';
import '../widgets/appwrite_timer_widget.dart';
import '../core/logging/app_logger.dart';
import '../constants/appwrite.dart';
import 'dart:convert';
import '../widgets/instant_message_bell.dart';
import '../widgets/challenge_bell.dart';
import '../widgets/mattermost_chat_widget.dart';
import '../models/user_profile.dart';
import '../models/discussion_chat_message.dart';
import '../services/firebase_gift_service.dart';
import '../models/gift.dart';
import '../widgets/user_profile_bottom_sheet.dart';
import '../screens/email_compose_screen.dart';
import '../core/navigation/optimized_navigation.dart';

// Color constants
const Color scarletRed = Color(0xFFFF2400);
const Color lightScarlet = Color(0xFFFFF1F0);
const Color accentPurple = Color(0xFF8B5CF6);
const Color deepPurple = Color(0xFF6B46C1);
const Color darkGray = Color(0xFF2D2D2D);

// =====================================================
// MODERNIZED OPEN DISCUSSION SCREEN 
// Using new service-based architecture
// =====================================================

/// Open Discussion Room Screen using LiveKit-first architecture
/// Real-time synchronization handled entirely by LiveKit events
class OpenDiscussionScreen extends StatefulWidget {
  final String roomName; // Technical room name for LiveKit
  final String displayTitle; // Clean title for UI display
  final String userRole; // 'moderator', 'speaker', 'audience'
  final bool isNewRoom; // True if this is a newly created room (optimistic UI)
  final Map<String, dynamic>? roomCreationData; // Data for background room creation

  const OpenDiscussionScreen({
    super.key,
    required this.roomName,
    this.displayTitle = '',
    required this.userRole,
    this.isNewRoom = false,
    this.roomCreationData,
  });

  @override
  State<OpenDiscussionScreen> createState() => _OpenDiscussionScreenState();
}

class _OpenDiscussionScreenState extends State<OpenDiscussionScreen> with WidgetsBindingObserver {
  // =====================================================
  // NEW SERVICE-BASED ARCHITECTURE
  // =====================================================
  
  // Core services - Dependency injection ready
  final OpenDiscussionService _openDiscussionService = OpenDiscussionService();
  final AppwriteService _appwriteService = AppwriteService();
  final ParticipantPromotionService _promotionService = ParticipantPromotionService();
  late final ParticipantService _participantService;
  late final LiveKitConnectionManager _connectionManager;
  final ErrorBoundary _errorBoundary = ErrorBoundary();
  
  // Service state streams
  StreamSubscription<List<ParticipantData>>? _participantsSubscription;
  StreamSubscription<List<Map<String, dynamic>>>? _appwriteParticipantsSubscription;
  StreamSubscription<LiveKitConnectionStatus>? _connectionStatusSubscription;
  StreamSubscription<String>? _connectionErrorSubscription;
  StreamSubscription<Map<String, dynamic>>? _roomClosureSubscription;
  
  // Auto-refresh timer for participant synchronization
  Timer? _participantRefreshTimer;
  
  // Core room state
  lk.Room? _livekitRoom;
  lk.LocalParticipant? _localParticipant;
  String? _currentUserId;
  String _roomDisplayTitle = '';
  String? _currentRoomId;
  bool _isConnected = false;
  bool _isMuted = true;

  // UI state
  bool _isLoading = false; // Force false to show content immediately
  String? _errorMessage;
  bool _showChat = false;
  
  // Connection monitoring - Enhanced
  String _connectionQuality = 'Good';
  int _totalParticipants = 0;
  int _reconnectAttempts = 0;
  static const int maxReconnectAttempts = 3;

  // Resource management - Memory leak prevention
  RealtimeSubscription? _realtimeParticipantsSubscription;
  RealtimeSubscription? _roomDocumentSubscription;
  RealtimeSubscription? _participantStatusSubscription;
  Timer? _reconnectTimer;
  Timer? _heartbeatTimer;
  bool _isDisposing = false;

  // Gift system
  final FirebaseGiftService _firebaseGiftService = FirebaseGiftService();
  int _currentUserCoinBalance = 0;
  Gift? _selectedGift;
  Map<String, dynamic>? _selectedRecipient;
  
  // Hand raise tracking
  final Set<String> _handsRaised = {};
  
  // Header variables to match your exact implementation
  final List<Map<String, dynamic>> _participants = [];
  final Map<String, dynamic> _remoteStreams = {};
  bool _isAudioConnected = false;
  bool _isRealtimeHealthy = true;
  bool _isReconnecting = false;
  
  // Timer synchronization variables
  int _speakingTime = 300; // Default 5 minutes
  Timer? _speakingTimer;
  Timer? _fallbackRefreshTimer;
  bool _thirtySecondChimePlayed = false;
  StreamSubscription<RealtimeMessage>? _realtimeSubscription;
  static const int _maxReconnectAttempts = 5;
  String? _currentAppwriteUserId;

  // User profiles cache for avatars and usernames
  final Map<String, UserProfile> _userProfileCache = {};
  UserProfile? _currentUserProfile;

  // =====================================================
  // UNIFIED PARTICIPANT OPERATIONS
  // =====================================================
  
  /// Get current user's role from unified state
  String _getCurrentUserRole() {
    final currentUser = _participantService.getParticipant(_currentUserId ?? '');
    return currentUser?.role ?? widget.userRole;
  }

  /// Check if current user is moderator
  bool _isCurrentUserModerator() => _getCurrentUserRole() == 'moderator';

  /// Check if current user has raised hand
  bool _hasCurrentUserRaisedHand() => _getCurrentUserRole() == 'pending';

  /// Get count of pending hand raise requests
  int _getHandRaiseCount() => _participantService.pendingRequests.length;

  /// Check if event is for current room
  bool _isEventForCurrentRoom(String? payloadRoomId) {
    if (payloadRoomId == null) return false;
    return payloadRoomId == _currentRoomId || payloadRoomId == widget.roomName;
  }

  /// Update participant state in unified manager
  void _updateParticipantState({
    required String userId,
    String? displayName,
    String? avatarUrl,
    String? role,
    bool? isSpeaking,
    bool? isMuted,
    lk.Participant? liveKitParticipant,
  }) {
    final existing = _participantService.getParticipant(userId);
    final isLocal = userId == _currentUserId;
    
    if (existing != null) {
      final updated = existing.copyWith(
        displayName: displayName,
        avatarUrl: avatarUrl,
        role: role,
        isHandRaised: role == 'pending',
        isSpeaking: isSpeaking,
        isMuted: isMuted,
        liveKitParticipant: liveKitParticipant,
      );
      _participantService.updateParticipant(
        userId: userId,
        displayName: updated.displayName,
        avatarUrl: updated.avatarUrl,
        role: updated.role,
        isHandRaised: updated.isHandRaised,
        isSpeaking: updated.isSpeaking,
        isMuted: updated.isMuted,
        liveKitParticipant: updated.liveKitParticipant,
        isLocal: updated.isLocal,
      );
    } else {
      // Create new participant
      final participant = ParticipantData(
        id: userId,
        displayName: displayName ?? 'Unknown User',
        avatarUrl: avatarUrl,
        role: role ?? 'audience',
        isHandRaised: role == 'pending',
        isSpeaking: isSpeaking ?? false,
        isMuted: isMuted ?? true,
        liveKitParticipant: liveKitParticipant,
        isLocal: isLocal,
      );
      _participantService.updateParticipant(
        userId: userId,
        displayName: participant.displayName,
        avatarUrl: participant.avatarUrl,
        role: participant.role,
        isHandRaised: participant.isHandRaised,
        isSpeaking: participant.isSpeaking,
        isMuted: participant.isMuted,
        liveKitParticipant: participant.liveKitParticipant,
        isLocal: participant.isLocal,
      );
    }
    
    if (mounted) {
      setState(() {
        // Trigger rebuild with unified state
      });
    }
  }

  @override
  void initState() {
    super.initState();
    AppLogger().debug('üèÅ OpenDiscussionScreen: Initializing for room ${widget.roomName}');
    AppLogger().debug('üë§ User role: ${widget.userRole}');
    AppLogger().debug('üîç Is moderator: ${widget.userRole == 'moderator'}');
    
    // Initialize new services
    _participantService = ParticipantService(_appwriteService);
    _connectionManager = LiveKitConnectionManager();
    
    // Setup service subscriptions
    _setupServiceSubscriptions();
    
    // Initialize display title immediately from passed parameter
    if (widget.displayTitle.isNotEmpty) {
      _roomDisplayTitle = widget.displayTitle;
      AppLogger().debug('üìã Initial room display title set: $_roomDisplayTitle');
    }
    
    // Add lifecycle observer for app state changes
    WidgetsBinding.instance.addObserver(this);
    
    // Set basic data so UI can render immediately
    _currentRoomId = widget.roomName;
    _currentUserId = 'temp-user-id'; // Will be updated when auth completes
    
    // Initialize room in background - don't wait for it
    _initializeRoom();
    
    // Initialize gift system
    _loadFirebaseCoinBalance();
  }

  /// Handle app lifecycle changes to refresh participants when app becomes active
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    if (state == AppLifecycleState.resumed && !_isDisposing && mounted && _currentRoomId != null) {
      AppLogger().debug('üîÑ App resumed - refreshing participants');
      _loadRoomParticipants();
    }
  }

  /// Set up participant status subscription after user authentication
  void _setupParticipantStatusSubscription() {
    if (_currentUserId == null || _currentUserId == 'temp-user-id') {
      AppLogger().debug('‚è≥ Participant status subscription - waiting for user authentication');
      return;
    }
    
    try {
      AppLogger().debug('üîî Setting up participant status subscription for user: $_currentUserId');
      
      _participantStatusSubscription = _appwriteService.realtime.subscribe([
        'databases.${AppwriteConstants.databaseId}.collections.${AppwriteConstants.roomParticipantsCollection}.documents',
      ]);
      
      _participantStatusSubscription!.stream.listen(
        (response) {
          if (_isDisposing || !mounted) return;
          
          AppLogger().debug('üîî Participant status update: ${response.events}');
          AppLogger().debug('üîî Participant payload: ${response.payload}');
          
          // Check if this is our participant being updated to room_closed
          if (response.payload != null) {
            final participantData = response.payload;
            final participantUserId = participantData['userId'];
            final participantStatus = participantData['status'];
            final participantRoomId = participantData['roomId'];
            
            AppLogger().debug('üîî Participant update - userId: $participantUserId, status: $participantStatus, roomId: $participantRoomId');
            AppLogger().debug('üîî Current user: $_currentUserId, current room: $_currentRoomId');
            
            // If this is our user in our current room and status is room_closed
            if (participantUserId == _currentUserId && 
                participantRoomId == _currentRoomId && 
                participantStatus == 'room_closed') {
              AppLogger().debug('üö™ Room closure detected via participant status update');
              
              if (mounted) {
                // Force disconnect and navigate away immediately
                _forceDisconnectFromRoom();
                
                // Show room closed dialog
                _showRoomClosedDialog({
                  'roomId': participantRoomId,
                  'roomTitle': _roomDisplayTitle ?? 'Room',
                  'message': 'This room has been closed by the moderator',
                  'reason': participantData['leftReason'] ?? 'moderator_closed',
                  'closedBy': participantData['closedBy'] ?? 'moderator',
                });
                
                // Navigate to home screen after short delay
                Future.delayed(const Duration(seconds: 2), () {
                  if (mounted) {
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute(builder: (_) => const OptimizedMainNavigator()),
                      (route) => false,
                    );
                  }
                });
              }
            }
          }
        },
        onError: (error) {
          AppLogger().error('‚ùå Participant status subscription error: $error');
        },
      );
      
      AppLogger().debug('‚úÖ Participant status subscription set up successfully');
      
    } catch (e) {
      AppLogger().warning('‚ö†Ô∏è Failed to setup participant status subscription: $e');
    }
  }

  /// Setup service subscriptions for reactive updates
  void _setupServiceSubscriptions() {
    // Listen to participant changes
    _participantsSubscription = _participantService.participantsStream.listen(
      (participants) {
        if (mounted) {
          setState(() {
            _totalParticipants = participants.length;
            // Update _participants list for header display
            _participants.clear();
            _participants.addAll(participants.map((p) => {
              'userId': p.id,
              'role': p.role,
              'displayName': p.displayName,
            }).toList());
          });
        }
      },
      onError: (error) => _errorBoundary.handleError(
        error,
        context: 'Participant stream subscription',
      ),
    );

    // Listen to connection status changes
    _connectionStatusSubscription = _connectionManager.statusStream.listen(
      (status) {
        if (mounted) {
          setState(() {
            _isConnected = status == LiveKitConnectionStatus.connected;
            // Update header variables to match your exact implementation
            _isAudioConnected = status == LiveKitConnectionStatus.connected;
            _isReconnecting = status == LiveKitConnectionStatus.reconnecting;
            _isRealtimeHealthy = status == LiveKitConnectionStatus.connected;
          });
        }
      },
      onError: (error) => _errorBoundary.handleLiveKitError(
        error,
        context: 'Connection status subscription',
      ),
    );

    // Listen to connection errors
    _connectionErrorSubscription = _connectionManager.errorStream.listen(
      (errorMessage) {
        if (mounted) {
          setState(() {
            _errorMessage = errorMessage;
          });
        }
      },
    );

    // Listen for room closure notifications
    _roomClosureSubscription = _openDiscussionService.roomClosureStream.listen(
      (closureData) {
        AppLogger().debug('üîî Room closure stream received data: $closureData');
        final closedRoomId = closureData['roomId'] as String?;
        
        AppLogger().debug('üîç Comparing closed room ID: $closedRoomId with current: $_currentRoomId and widget: ${widget.roomName}');
        
        // Check if this is our current room being closed
        if (closedRoomId == _currentRoomId || closedRoomId == widget.roomName) {
          AppLogger().debug('üö™ Current room was closed: ${closureData['roomTitle']}');
          
          if (mounted) {
            // Immediately disconnect from LiveKit
            _forceDisconnectFromRoom();
            
            // Show closure notification
            _showRoomClosedDialog(closureData);
            
            // Navigate to home screen after short delay
            Future.delayed(const Duration(seconds: 2), () {
              if (mounted) {
                // Pop all routes until we're back at the main navigator
                Navigator.of(context).pushAndRemoveUntil(
                  MaterialPageRoute(builder: (_) => const OptimizedMainNavigator()),
                  (route) => false,
                );
              }
            });
          }
        }
      },
      onError: (error) {
        AppLogger().error('‚ùå Room closure stream error: $error');
      },
    );

    // Note: Participant status subscription will be set up after user authentication

    // Add direct room document subscription to catch status changes immediately  
    if (_currentRoomId != null) {
      try {
        _roomDocumentSubscription = _appwriteService.realtime.subscribe([
          'databases.${AppwriteConstants.databaseId}.collections.${AppwriteConstants.debateDiscussionRoomsCollection}.documents.${_currentRoomId}'
        ]);
        
        _roomDocumentSubscription!.stream.listen(
          (response) {
            if (_isDisposing || !mounted) return;
            
            AppLogger().debug('üîî Room document update: ${response.events}');
            AppLogger().debug('üîî Room payload: ${response.payload}');
            
            if (response.payload != null && response.payload['status'] == 'closed') {
              AppLogger().debug('üö™ Room closed detected via direct subscription');
              
              _forceDisconnectFromRoom();
              _showRoomClosedDialog({
                'roomId': response.payload['\$id'],
                'roomTitle': response.payload['title'] ?? 'Unknown Room',
                'message': 'This room has been closed by the moderator',
                'reason': response.payload['closureReason'] ?? 'moderator_closed',
              });
              
              Future.delayed(const Duration(seconds: 1), () {
                if (mounted) {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (context) => const OptimizedMainNavigator()),
                    (route) => false,
                  );
                }
              });
            }
          },
          onError: (error) {
            AppLogger().error('‚ùå Room document subscription error: $error');
          },
        );
      } catch (e) {
        AppLogger().warning('‚ö†Ô∏è Could not setup room document subscription: $e');
      }
    }

    // Also listen for participant status changes - if our user is marked as 'left', disconnect
    _appwriteParticipantsSubscription = _openDiscussionService.participantsStream.listen(
      (participants) {
        if (_currentUserId != null) {
          final currentUserParticipant = participants.firstWhere(
            (p) => p['userId'] == _currentUserId,
            orElse: () => <String, dynamic>{},
          );
          
          // If our user status changed to 'left', we were kicked out
          if (currentUserParticipant.isNotEmpty && currentUserParticipant['status'] == 'left') {
            final leftReason = currentUserParticipant['leftReason'] ?? 'unknown';
            AppLogger().debug('üö™ Current user marked as left, reason: $leftReason');
            
            if (leftReason == 'moderator_closed' && mounted) {
              // Force disconnect and show closure dialog
              _forceDisconnectFromRoom();
              _showRoomClosedDialog({
                'roomId': _currentRoomId ?? '',
                'roomTitle': _roomDisplayTitle,
                'message': 'This room has been closed by the moderator',
                'reason': leftReason,
              });
              
              Future.delayed(const Duration(seconds: 2), () {
                if (mounted) {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (context) => const OptimizedMainNavigator()),
                    (route) => false,
                  );
                }
              });
            }
          }
        }
      },
      onError: (error) {
        AppLogger().error('‚ùå Participants stream error: $error');
      },
    );
  }

  @override
  void dispose() {
    AppLogger().debug('üßπ OpenDiscussionScreen: Starting disposal');
    _isDisposing = true;
    
    // Remove lifecycle observer
    WidgetsBinding.instance.removeObserver(this);
    
    // IMMEDIATELY stop all audio to prevent bleeding
    try {
      if (_localParticipant != null) {
        _localParticipant!.setMicrophoneEnabled(false);
        AppLogger().info('üîá Emergency microphone disable to prevent audio bleeding');
      }
    } catch (e) {
      AppLogger().error('‚ùå Failed to disable microphone during disposal: $e');
    }
    
    // Cancel all timers first to prevent callbacks during disposal
    _reconnectTimer?.cancel();
    _heartbeatTimer?.cancel();
    _speakingTimer?.cancel();
    _fallbackRefreshTimer?.cancel();
    
    // Close real-time subscriptions
    _realtimeSubscription?.cancel();
    _realtimeParticipantsSubscription?.close();
    _roomDocumentSubscription?.close();
    _participantStatusSubscription?.close();
    _participantsSubscription?.cancel();
    _appwriteParticipantsSubscription?.cancel();
    _connectionStatusSubscription?.cancel();
    _connectionErrorSubscription?.cancel();
    _roomClosureSubscription?.cancel();
    
    // Cleanup participants stream
    _openDiscussionService.cleanupParticipantsStream();
    
    // Clean up services
    _participantService.dispose();
    _connectionManager.dispose();
    _errorBoundary.dispose();
    
    // Leave room data cleanup - ensures proper cleanup when closing screen
    _leaveRoomData().timeout(
      const Duration(seconds: 3),
      onTimeout: () {
        AppLogger().warning('‚ö†Ô∏è Leave room data cleanup timed out');
      },
    );
    
    // Disconnect from room with timeout
    _disconnectFromRoom().timeout(
      const Duration(seconds: 5),
      onTimeout: () {
        AppLogger().warning('‚ö†Ô∏è Room disconnection timed out');
      },
    );
    
    // Participant manager already cleared above
    
    AppLogger().debug('‚úÖ OpenDiscussionScreen: Disposal complete');
    super.dispose();
  }

  Future<void> _initializeRoom() async {
    int attempts = 0;

    while (attempts < maxReconnectAttempts && !_isDisposing) {
      try {
        attempts++;
        AppLogger().debug('üèÅ Room initialization attempt $attempts/$maxReconnectAttempts');
        
        if (!mounted) return;
        setState(() {
          _isLoading = true;
          _errorMessage = null;
          _reconnectAttempts = attempts - 1;
        });

        // Fast path for moderators (room creators) - they don't need to wait for room lookup
        if (widget.userRole == 'moderator') {
          await _initializeRoomAsModerator();
        } else {
          await _initializeRoomAsParticipant();
        }
        
        break; // Success - exit retry loop
        
      } catch (e, st) {
        AppLogger().error('‚ùå Room initialization attempt $attempts failed: $e\n$st');
        
        if (attempts >= maxReconnectAttempts) {
          if (mounted) {
            setState(() {
              _isLoading = false;
              _errorMessage = 'Failed to initialize room after $attempts attempts: $e';
            });
          }
          break;
        }
        
        // Wait before retry
        await Future.delayed(Duration(seconds: attempts * 2));
      }
    }
  }

  /// Fast initialization path for moderators (room creators)
  Future<void> _initializeRoomAsModerator() async {
    AppLogger().debug('üöÄ Fast moderator initialization starting (isNewRoom: ${widget.isNewRoom})');
    
    // Get current user with shorter timeout for moderators
    final user = await _appwriteService.getCurrentUser().timeout(
      const Duration(seconds: 3), // Even faster for optimistic UI
      onTimeout: () => throw TimeoutException('User authentication timed out'),
    );
    
    if (user == null) {
      throw Exception('No authenticated user found');
    }
    _currentUserId = user.$id;

    // Set room title immediately from widget (no need to fetch from DB)
    _roomDisplayTitle = widget.displayTitle.isNotEmpty ? widget.displayTitle : widget.roomName;
    
    // Set current room ID for moderator (needed for participant joining)
    _currentRoomId = widget.roomName;
    
    // Set up participant status subscription now that we have user ID
    _setupParticipantStatusSubscription();
    
    // Load user profile in background (don't wait)
    _loadUserProfileInBackground(user);
    
    // Connect to LiveKit immediately - moderators don't need to wait
    final displayName = user.name;
    
    final connected = await _connectionManager.connect(
      roomName: widget.roomName,
      userId: user.$id,
      displayName: displayName,
      userRole: widget.userRole,
    );
    
    if (!connected) {
      throw Exception('Failed to connect to LiveKit room');
    }
    
    // Get the room reference from connection manager
    _livekitRoom = _connectionManager.room;
    _localParticipant = _livekitRoom?.localParticipant;
    
    // For moderators, always add to participant service immediately
    _updateParticipantState(
      userId: user.$id,
      displayName: displayName,
      avatarUrl: null, // Will be loaded in background
      role: 'moderator',
    );
    
    // Handle database sync differently for new vs existing rooms
    if (widget.isNewRoom) {
      // NEW ROOM: Skip database operations during initialization (room being created in background)
      AppLogger().debug('üöÄ OPTIMISTIC: Skipping database sync for new room - will be handled in background');
      _handleNewRoomCreation();
    } else {
      // EXISTING ROOM: Try to join room participants database
      try {
        await _joinRoomParticipantsWithRetry();
        AppLogger().debug('‚úÖ Moderator added to existing room participants database');
      } catch (e) {
        AppLogger().debug('‚ö†Ô∏è Could not add moderator to room participants DB: $e');
      }
    }
    
    // Initialize essential services in parallel
    final futures = <Future>[
      // Setup real-time subscriptions
      Future(() => _setupParticipantsSubscription()),
      // Initialize timer
      _initializeTimer(),
      // Start health monitoring
      Future(() => _startHealthMonitoring()),
    ];
    
    // Wait for critical services, but don't block UI
    await Future.wait(futures, eagerError: false);
    
    // Initialize streams and periodic updates in background
    _initializeBackgroundServices();
    
    // Show UI immediately
    if (mounted) {
      setState(() {
        _isLoading = false;
        _isConnected = true;
      });
    }
    
    AppLogger().debug('‚úÖ Fast moderator initialization complete');
  }

  /// Standard initialization path for participants
  Future<void> _initializeRoomAsParticipant() async {
    // Get current user with timeout
    final user = await _appwriteService.getCurrentUser().timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('User authentication timed out'),
    );
    
    if (user == null) {
      throw Exception('No authenticated user found');
    }
    _currentUserId = user.$id;

    AppLogger().debug('üîê Generating room token for ${user.$id} as ${widget.userRole}');
    
    // Set up participant status subscription now that we have user ID
    _setupParticipantStatusSubscription();
    
    // Load current user's profile first for proper identification
    _currentUserProfile = await _appwriteService.getUserProfile(user.$id);
    if (_currentUserProfile != null) {
      _userProfileCache[user.$id] = _currentUserProfile!;
      AppLogger().info('‚úÖ Current user profile loaded: ${_currentUserProfile!.displayName}');
    }
    
    // Initialize room components sequentially to ensure proper order
    await _fetchRoomTitleFromAppwrite();
    await _joinRoomParticipantsWithRetry();
    
    // Connect using ConnectionManager with authenticated user profile
    final displayName = _currentUserProfile?.name ?? user.name;
    
    final connected = await _connectionManager.connect(
      roomName: widget.roomName,
      userId: user.$id,
      displayName: displayName,
      userRole: widget.userRole,
    );
    
    if (!connected) {
      throw Exception('Failed to connect to LiveKit room');
    }
    
    // Get the room reference from connection manager
    _livekitRoom = _connectionManager.room;
    _localParticipant = _livekitRoom?.localParticipant;
    
    await _loadRoomParticipants();
    
    // Setup real-time subscriptions with error handling
    _setupParticipantsSubscription();
    
    // Initialize participants stream for auto-refresh
    _openDiscussionService.initializeParticipantsStream(_currentRoomId!);
    _setupAppwriteParticipantsStream();
    
    // Start periodic participant refresh for better synchronization
    _startPeriodicParticipantRefresh();
    
    // Start health monitoring
    _startHealthMonitoring();

    if (mounted) {
      setState(() {
        _isLoading = false;
        _isConnected = true;
      });
    }
  }

  /// Load user profile in background without blocking initialization
  void _loadUserProfileInBackground(models.User user) {
    _appwriteService.getUserProfile(user.$id).then((profile) {
      if (profile != null && mounted) {
        _currentUserProfile = profile;
        _userProfileCache[user.$id] = profile;
        AppLogger().debug('‚úÖ Background user profile loaded: ${profile.displayName}');
        // Trigger a small UI update if needed
        if (mounted) setState(() {});
      }
    }).catchError((e) {
      AppLogger().debug('‚ö†Ô∏è Background user profile loading failed: $e');
    });
  }

  /// Initialize background services that don't block the UI
  void _initializeBackgroundServices() {
    // Run these in background without blocking UI
    Future(() {
      if (_currentRoomId != null) {
        _openDiscussionService.initializeParticipantsStream(_currentRoomId!);
        _setupAppwriteParticipantsStream();
      }
    });
    
    Future(() {
      _startPeriodicParticipantRefresh();
    });
    
    // Load room participants in background to ensure all participants show
    Future(() {
      _loadRoomParticipants();
    });
    
    // For moderators, ensure they appear immediately with multiple safety checks
    if (widget.userRole == 'moderator') {
      // Safety check #1: After 1 second
      Timer(const Duration(seconds: 1), () {
        if (mounted && _currentUserId != null) {
          final moderatorExists = _participantService.all.any((p) => p.id == _currentUserId);
          if (!moderatorExists) {
            AppLogger().debug('üîß Safety Check #1: Adding moderator to participant service');
            _updateParticipantState(
              userId: _currentUserId!,
              displayName: _currentUserProfile?.displayName ?? 'Moderator',
              avatarUrl: _currentUserProfile?.avatar,
              role: 'moderator',
            );
          }
        }
      });
      
      // Safety check #2: After 3 seconds (in case database sync takes time)
      Timer(const Duration(seconds: 3), () {
        if (mounted && _currentUserId != null) {
          final moderatorExists = _participantService.all.any((p) => p.id == _currentUserId);
          if (!moderatorExists) {
            AppLogger().debug('üîß Safety Check #2: Re-adding moderator to participant service');
            _updateParticipantState(
              userId: _currentUserId!,
              displayName: _currentUserProfile?.displayName ?? 'Moderator',
              avatarUrl: _currentUserProfile?.avatar,
              role: 'moderator',
            );
            // Force UI rebuild
            if (mounted) setState(() {});
          }
        }
      });
    }
  }

  /// Handle new room creation in background (optimistic UI)
  void _handleNewRoomCreation() {
    if (widget.roomCreationData == null) {
      AppLogger().debug('‚ö†Ô∏è No room creation data provided for new room');
      return;
    }

    // Create room in background without blocking UI
    Future(() async {
      try {
        AppLogger().debug('üîÑ BACKGROUND: Creating room in Appwrite database');
        
        final data = widget.roomCreationData!;
        await _openDiscussionService.createRoom(
          roomName: widget.roomName,
          displayTitle: data['displayTitle'] ?? widget.displayTitle,
          description: data['description'] ?? '',
          category: data['category'] ?? 'General',
          moderatorId: data['moderatorId'] ?? _currentUserId ?? '',
          maxParticipants: data['maxParticipants'] ?? 0,
          emptyTimeout: 600,
        );

        AppLogger().debug('‚úÖ BACKGROUND: Room created successfully in database');
        
        // Now that room exists in database, sync moderator to participants
        if (mounted && _currentUserId != null) {
          try {
            await _joinRoomParticipantsWithRetry();
            AppLogger().debug('‚úÖ BACKGROUND: Moderator synced to room participants');
          } catch (e) {
            AppLogger().debug('‚ö†Ô∏è BACKGROUND: Could not sync moderator to room participants: $e');
          }
        }
        
      } catch (e) {
        AppLogger().error('‚ùå BACKGROUND: Room creation failed: $e');
        // Room creation failed - but moderator is still in LiveKit room
        // Show a subtle notification to user if needed
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Room setup completed with some limitations'),
              duration: Duration(seconds: 2),
              backgroundColor: Colors.orange,
            ),
          );
        }
      }
    });

    // Start background database sync attempts with retry
    Timer.periodic(const Duration(seconds: 5), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }
      
      // Try to sync to database every 5 seconds until successful
      if (_currentUserId != null) {
        _joinRoomParticipantsWithRetry().then((_) {
          AppLogger().debug('‚úÖ PERIODIC: Successfully synced to room participants');
          timer.cancel(); // Stop trying once successful
        }).catchError((e) {
          AppLogger().debug('‚ö†Ô∏è PERIODIC: Sync attempt failed, will retry: $e');
        });
      }
    });
  }

  /// Get user-friendly error message
  String _getUserFriendlyErrorMessage(Exception? error) {
    if (error == null) return 'Unknown error occurred';
    
    final errorStr = error.toString().toLowerCase();
    
    if (errorStr.contains('timeout') || errorStr.contains('network')) {
      return 'Network connection issue. Please check your internet connection and try again.';
    } else if (errorStr.contains('authentication') || errorStr.contains('user')) {
      return 'Authentication failed. Please log in again.';
    } else if (errorStr.contains('permission') || errorStr.contains('denied')) {
      return 'Permission denied. Please check your microphone permissions.';
    } else if (errorStr.contains('room') && errorStr.contains('not found')) {
      return 'Room not found. It may have been deleted or is no longer active.';
    } else {
      return 'Failed to join room. Please try again.';
    }
  }

  /// Generate room token with retry logic
  Future<String> _generateRoomTokenWithRetry(String userId) async {
    for (int i = 0; i < 3; i++) {
      try {
        return _openDiscussionService.generateRoomToken(
          roomName: widget.roomName,
          identity: userId,
          role: widget.userRole,
        );
      } catch (e) {
        if (i == 2) rethrow; // Last attempt
        await Future.delayed(Duration(milliseconds: 500 * (i + 1)));
      }
    }
    throw Exception('Failed to generate token after retries');
  }

  /// Join room participants with retry logic
  Future<void> _joinRoomParticipantsWithRetry() async {
    for (int i = 0; i < 3; i++) {
      try {
        await _joinRoomParticipants();
        return;
      } catch (e) {
        AppLogger().warning('‚ö†Ô∏è Join room participants attempt ${i + 1} failed: $e');
        if (i == 2) {
          // Don't rethrow - this is not critical for core functionality
          AppLogger().warning('‚ö†Ô∏è Could not join room participants collection, continuing anyway');
          return;
        }
        await Future.delayed(Duration(milliseconds: 500 * (i + 1)));
      }
    }
  }

  /// Connect to room with retry and fallback
  Future<void> _connectToRoomWithRetry(String token) async {
    for (int i = 0; i < 3; i++) {
      try {
        await _connectToRoom(token);
        return;
      } catch (e) {
        AppLogger().warning('‚ö†Ô∏è LiveKit connection attempt ${i + 1} failed: $e');
        if (i == 2) rethrow; // Last attempt failed
        
        // Progressive delay
        await Future.delayed(Duration(seconds: i + 1));
      }
    }
  }

  /// Start health monitoring
  void _startHealthMonitoring() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = Timer.periodic(const Duration(seconds: 30), (_) {
      _performHealthCheck();
    });
  }

  /// Perform health check
  void _performHealthCheck() {
    if (_isDisposing || !mounted) return;
    
    final isHealthy = _connectionManager.isConnected && _isConnected;
    
    if (!isHealthy && _reconnectAttempts < maxReconnectAttempts) {
      AppLogger().warning('‚ö†Ô∏è Health check failed - attempting recovery');
      _attemptReconnection();
    }
  }

  /// Attempt to reconnect when connection is lost
  void _attemptReconnection() async {
    if (_isDisposing || !mounted) return;
    
    _reconnectTimer?.cancel();
    _reconnectTimer = Timer(const Duration(seconds: 5), () async {
      if (!_isDisposing && mounted && _currentUserId != null) {
        AppLogger().info('üîÑ Attempting automatic reconnection');
        // Use connect method for reconnection
        final displayName = _currentUserProfile?.name ?? 'Unknown User';
        
        final success = await _connectionManager.connect(
          roomName: widget.roomName,
          userId: _currentUserId!,
          displayName: displayName,
          userRole: widget.userRole,
        );
        
        if (success && mounted) {
          setState(() {
            _isConnected = true;
            _reconnectAttempts = 0;
          });
        }
      }
    });
  }

  Future<void> _connectToRoom(String token) async {
    try {
      AppLogger().debug('üîó Connecting to LiveKit room: ${widget.roomName}');

      // Initialize LiveKit room
      _livekitRoom = lk.Room();
      
      // Set up event listeners
      _setupRoomListeners();

      // Connect to room
      await _livekitRoom!.connect(
        'ws://172.236.109.9:7880', // TODO: Use ConnectionManager instead
        token,
      );

      _localParticipant = _livekitRoom!.localParticipant;
      _isConnected = true;
      
      // Hand raise state will be tracked locally in this client
      // No need to check LiveKit metadata since we're using Appwrite

      // Enable microphone based on role (check both initial role and current participant service role)
      final currentParticipant = _participantService.getParticipant(_currentUserId!);
      final currentRole = currentParticipant?.role ?? widget.userRole;
      
      if (currentRole == 'moderator' || currentRole == 'speaker') {
        await _localParticipant!.setMicrophoneEnabled(true);
        _syncMuteState(); // Sync UI with actual LiveKit state
        AppLogger().debug('üé§ Microphone enabled for $currentRole');
      } else {
        _syncMuteState(); // Sync UI state for audience members too
      }

      AppLogger().debug('‚úÖ Connected to LiveKit room successfully');
      
      // Load current user's profile (moderator/speaker)
      if (_currentUserId != null) {
        await _loadUserProfile(_currentUserId!);
      }
      
      // Load initial participants
      _updateParticipantsList();
      
    } catch (e) {
      AppLogger().error('‚ùå Failed to connect to LiveKit room: $e');
      rethrow;
    }
  }

  void _setupRoomListeners() {
    _livekitRoom!.addListener(_onRoomUpdate);

    final listener = _livekitRoom!.createListener();

    // Participant events
    listener.on<lk.ParticipantConnectedEvent>((event) {
      AppLogger().debug('üëã Participant connected: ${event.participant.identity}');
      _updateParticipantsList();
      _loadUserProfile(event.participant.identity);
    });

    listener.on<lk.ParticipantDisconnectedEvent>((event) {
      AppLogger().debug('üëã Participant disconnected: ${event.participant.identity}');
      _updateParticipantsList();
    });

    // Audio track events
    listener.on<lk.TrackPublishedEvent>((event) {
      AppLogger().debug('üéµ Track published: ${event.participant.identity}');
      _updateParticipantsList();
    });

    listener.on<lk.TrackUnpublishedEvent>((event) {
      AppLogger().debug('üîá Track unpublished: ${event.participant.identity}');
      _updateParticipantsList();
    });

    // Listen for participant permission changes (if supported by LiveKit Flutter SDK)  
    // This provides additional responsiveness when server updates permissions
    try {
      listener.on<lk.ParticipantPermissionsUpdatedEvent>((event) {
        AppLogger().debug('üîë Participant permissions updated: ${event.participant.identity}');
        
        // If it's the current user and they now have publish permissions, try enabling mic
        if (event.participant.identity == _currentUserId) {
          final permissions = event.participant.permissions;
          if (permissions.canPublish) {
            AppLogger().info('üé§ Received publish permissions from server - enabling microphone');
            _enableMicrophoneSimple();
          }
        }
      });
    } catch (e) {
      // ParticipantPermissionsUpdatedEvent might not be available in this SDK version
      AppLogger().debug('üìù ParticipantPermissionsUpdatedEvent not supported in this SDK version');
    }
    
    // Room metadata events - removed since using Appwrite as source of truth
  }

  void _onRoomUpdate() {
    if (mounted) {
      setState(() {
        _updateParticipantsList();
      });
    }
  }


  /// Fetch clean room title from Appwrite database and store room ID
  Future<void> _fetchRoomTitleFromAppwrite() async {
    try {
      AppLogger().debug('üìã Fetching room title from Appwrite for room: ${widget.roomName}');
      
      // Search for the room in Appwrite - get all active open discussion rooms
      final roomsResponse = await _appwriteService.databases.listDocuments(
        databaseId: AppwriteConstants.databaseId,
        collectionId: AppwriteConstants.roomsCollection,
        queries: [
          Query.equal('type', 'open_discussion'),
          Query.equal('status', 'active'),
        ],
      );

      AppLogger().debug('üìã Found ${roomsResponse.documents.length} open discussion rooms in Appwrite');

      // Find the room with matching LiveKit room name
      for (final doc in roomsResponse.documents) {
        final data = doc.data;
        final settings = data['settings'] != null 
            ? jsonDecode(data['settings'] as String) 
            : <String, dynamic>{};
        
        // Check if this room's LiveKit name matches our technical room name
        final liveKitRoomName = settings['liveKitRoomName'];
        AppLogger().debug('üìã Checking room: ${data['title']} (livekit: $liveKitRoomName vs ${widget.roomName})');
        
        if (liveKitRoomName == widget.roomName) {
          // Found the matching room! Get the clean title and use LiveKit room name as consistent ID
          final cleanTitle = data['title'] as String?;
          if (cleanTitle != null && cleanTitle.isNotEmpty) {
            setState(() {
              _roomDisplayTitle = cleanTitle;
              _currentRoomId = widget.roomName; // Use LiveKit room name for consistency across all devices
            });
            AppLogger().debug('‚úÖ Found clean room title: $_roomDisplayTitle (using LiveKit room name as consistent ID: $_currentRoomId)');
            return;
          }
        }
      }
      
      AppLogger().debug('‚ö†Ô∏è Could not find room in Appwrite with LiveKit name: ${widget.roomName}');
      
      // CRITICAL FIX: If room not found in Appwrite, use widget.roomName as fallback room ID
      // This ensures _currentRoomId is never null, enabling participant subscriptions
      if (_currentRoomId == null) {
        setState(() {
          _currentRoomId = widget.roomName;
          _roomDisplayTitle = widget.displayTitle.isNotEmpty ? widget.displayTitle : widget.roomName;
        });
        AppLogger().debug('üîß Using fallback room ID: $_currentRoomId');
      }
    } catch (e) {
      _errorBoundary.handleAppwriteError(
        e,
        context: 'Fetching room title from Appwrite',
      );
      
      // CRITICAL FIX: Ensure _currentRoomId is never null even on errors
      if (_currentRoomId == null) {
        setState(() {
          _currentRoomId = widget.roomName;
          _roomDisplayTitle = widget.displayTitle.isNotEmpty ? widget.displayTitle : widget.roomName;
        });
        AppLogger().debug('üîß Using fallback room ID after error: $_currentRoomId');
      }
    }
  }

  /// Join Room Participants collection when entering room
  Future<void> _joinRoomParticipants() async {
    if (_currentRoomId == null || _currentUserId == null) {
      AppLogger().debug('‚ö†Ô∏è Cannot join room participants - missing room ID or user ID');
      return;
    }

    try {
      // Use cached user profile for avatar and display name
      final userName = _currentUserProfile?.displayName ?? 'Unknown User';
      final userAvatar = _currentUserProfile?.avatar;

      await _openDiscussionService.addRoomParticipant(
        roomId: _currentRoomId!,
        userId: _currentUserId!,
        userName: userName,
        userAvatar: userAvatar,
        role: widget.userRole,
      );

      AppLogger().debug('‚úÖ Successfully joined Room Participants collection');
    } catch (e) {
      AppLogger().error('‚ùå Failed to join Room Participants: $e');
      // Don't rethrow - this is not critical for room functionality
    }
  }

  /// Load all room participants from collection into unified manager
  /// Load room participants from Appwrite with user profiles
  Future<void> _loadRoomParticipants() async {
    if (_currentRoomId == null) {
      AppLogger().debug('‚ö†Ô∏è Cannot load room participants - missing room ID');
      return;
    }

    try {
      final participants = await _openDiscussionService.getRoomParticipants(_currentRoomId!);
      
      for (final participantData in participants) {
        final userId = participantData['userId'] as String;
        final role = participantData['role'] as String? ?? 'audience';
        
        // Load user profile for this participant if not cached
        if (!_userProfileCache.containsKey(userId)) {
          try {
            final profile = await _appwriteService.getUserProfile(userId);
            if (profile != null) {
              _userProfileCache[userId] = profile;
            }
          } catch (e) {
            AppLogger().debug('‚ö†Ô∏è Failed to load profile for participant $userId: $e');
          }
        }
        
        final profile = _userProfileCache[userId];
        final displayName = profile?.displayName ?? participantData['displayName'] as String? ?? 'Unknown User';
        final avatarUrl = profile?.avatar ?? participantData['avatarUrl'] as String?;
        
        _updateParticipantState(
          userId: userId,
          displayName: displayName,
          avatarUrl: avatarUrl,
          role: role,
        );
      }

      AppLogger().debug('‚úÖ Loaded ${participants.length} room participants with profiles into unified manager');
    } catch (e) {
      AppLogger().error('‚ùå Failed to load room participants: $e');
      // Don't rethrow - fallback to existing participant loading
    }
  }

  /// Setup real-time subscription for participant changes with error recovery
  void _setupParticipantsSubscription() {
    if (_currentRoomId == null) {
      AppLogger().debug('‚ö†Ô∏è Cannot setup participants subscription - missing room ID');
      return;
    }

    try {
      AppLogger().debug('üîÑ Setting up real-time participants subscription for room: $_currentRoomId');
      
      // Close existing subscription if any
      _realtimeParticipantsSubscription?.close();
      
      _realtimeParticipantsSubscription = _appwriteService.realtime.subscribe([
        'databases.${AppwriteConstants.databaseId}.collections.${AppwriteConstants.debateDiscussionParticipantsCollection}.documents'
      ]);

      // Listen with error handling and automatic retry
      _realtimeParticipantsSubscription!.stream.listen(
        (response) {
          if (_isDisposing || !mounted) return;
          
          AppLogger().debug('üîÑ Participants subscription event: ${response.events}');
          
          try {
            // Process event with timeout
            _processRealtimeEvent(response);
          } catch (e) {
            AppLogger().error('‚ùå Error processing participant subscription event: $e');
            AppLogger().error('üì¶ Problematic payload: ${response.payload}');
          }
        },
        onError: (error) {
          AppLogger().error('‚ùå Real-time subscription error: $error');
          
          // Attempt to reconnect after delay
          if (!_isDisposing && mounted) {
            Timer(const Duration(seconds: 5), () {
              if (!_isDisposing && mounted) {
                AppLogger().info('üîÑ Attempting to reconnect real-time subscription');
                _setupParticipantsSubscription();
              }
            });
          }
        },
        onDone: () {
          AppLogger().warning('‚ö†Ô∏è Real-time subscription closed');
          
          // Attempt to reconnect if not intentionally disposed
          if (!_isDisposing && mounted) {
            Timer(const Duration(seconds: 3), () {
              if (!_isDisposing && mounted) {
                AppLogger().info('üîÑ Reconnecting real-time subscription after closure');
                _setupParticipantsSubscription();
              }
            });
          }
        },
      );

      AppLogger().debug('‚úÖ Participants subscription setup completed');
    } catch (e) {
      AppLogger().error('‚ùå Failed to setup participants subscription: $e');
      
      // Retry setup after delay
      if (!_isDisposing && mounted) {
        Timer(const Duration(seconds: 10), () {
          if (!_isDisposing && mounted) {
            AppLogger().info('üîÑ Retrying participants subscription setup');
            _setupParticipantsSubscription();
          }
        });
      }
    }
  }

  /// Setup Appwrite participants stream for auto-refresh
  void _setupAppwriteParticipantsStream() {
    if (_currentRoomId == null) {
      AppLogger().debug('‚ö†Ô∏è Cannot setup Appwrite participants stream - missing room ID');
      return;
    }

    try {
      AppLogger().debug('üîÑ Setting up Appwrite participants stream for room: $_currentRoomId');
      
      // Close existing subscription if any
      _appwriteParticipantsSubscription?.cancel();
      
      // Listen to the participants stream from the service
      _appwriteParticipantsSubscription = _openDiscussionService.participantsStream.listen(
        (participants) {
          if (_isDisposing || !mounted) return;
          
          AppLogger().debug('üîÑ Received participants stream update: ${participants.length} participants');
          
          try {
            // Update the participant service with new data
            _updateParticipantServiceFromStream(participants);
          } catch (e) {
            AppLogger().error('‚ùå Error processing participants stream update: $e');
          }
        },
        onError: (error) {
          AppLogger().error('‚ùå Participants stream error: $error');
        },
      );

      AppLogger().debug('‚úÖ Appwrite participants stream setup completed');
    } catch (e) {
      AppLogger().error('‚ùå Failed to setup Appwrite participants stream: $e');
    }
  }

  /// Update participant service from stream data
  void _updateParticipantServiceFromStream(List<Map<String, dynamic>> participants) async {
    try {
      for (final participantData in participants) {
        final userId = participantData['userId'] as String;
        final role = participantData['role'] as String? ?? 'audience';
        
        // Load user profile for this participant if not cached
        if (!_userProfileCache.containsKey(userId)) {
          try {
            final profile = await _appwriteService.getUserProfile(userId);
            if (profile != null) {
              _userProfileCache[userId] = profile;
            }
          } catch (e) {
            AppLogger().debug('‚ö†Ô∏è Failed to load profile for participant $userId: $e');
          }
        }
        
        final profile = _userProfileCache[userId];
        final displayName = profile?.displayName ?? participantData['displayName'] as String? ?? 'Unknown User';
        final avatarUrl = profile?.avatar ?? participantData['avatarUrl'] as String?;
        
        _updateParticipantState(
          userId: userId,
          displayName: displayName,
          avatarUrl: avatarUrl,
          role: role,
        );
      }

      // Trigger UI rebuild
      if (mounted) {
        setState(() {
          // UI will automatically rebuild with updated participant data
        });
      }

      AppLogger().debug('‚úÖ Updated participant service from stream: ${participants.length} participants');
    } catch (e) {
      AppLogger().error('‚ùå Failed to update participant service from stream: $e');
    }
  }

  /// Start aggressive periodic participant refresh for better synchronization
  void _startPeriodicParticipantRefresh() {
    _participantRefreshTimer?.cancel();
    
    if (_currentRoomId == null) return;
    
    AppLogger().debug('üîÑ Starting aggressive periodic participant refresh (every 10 seconds)');
    
    _participantRefreshTimer = Timer.periodic(const Duration(seconds: 10), (timer) {
      if (_isDisposing || !mounted || _currentRoomId == null) {
        timer.cancel();
        return;
      }
      
      AppLogger().debug('üîÑ Aggressive periodic participant refresh triggered');
      _loadRoomParticipants();
      
      // Also force a UI refresh to ensure participants are displayed
      if (mounted) {
        setState(() {
          // Force UI update
        });
      }
    });
  }

  /// Process real-time event with simplified validation
  void _processRealtimeEvent(RealtimeMessage response) {
    // Validate payload
    final payload = response.payload;
    if (payload.isEmpty) {
      AppLogger().warning('‚ö†Ô∏è Empty payload received, ignoring');
      return;
    }

    final payloadRoomId = payload['roomId'];
    if (!_isEventForCurrentRoom(payloadRoomId)) {
      AppLogger().debug('‚ùå Room ID mismatch - skipping event (payload: "$payloadRoomId")');
      return;
    }
    
    AppLogger().debug('‚úÖ Room ID matches - processing participant change');
    _handleParticipantChange(response);
  }

  /// Handle real-time participant changes with unified state management
  void _handleParticipantChange(RealtimeMessage message) {
    if (!mounted) return;

    try {
      final payload = message.payload;
      AppLogger().debug('üì¶ Processing participant change: $payload');
      
      final userId = payload['userId'] as String?;
      final status = payload['status'] as String?;
      final role = payload['role'] as String?;
      final userName = payload['userName'] as String?;
      final userAvatar = payload['userAvatar'] as String?;

      if (userId == null) {
        AppLogger().warning('‚ö†Ô∏è Missing userId in participant change event');
        return;
      }

      AppLogger().debug('üë• Participant change: $userId ($status, role: $role)');

      // Handle different event types
      if (status == 'joined') {
        // User joined - add to unified manager
        _updateParticipantState(
          userId: userId,
          displayName: userName ?? 'Unknown User',
          avatarUrl: userAvatar,
          role: role ?? 'audience',
        );
        AppLogger().debug('‚úÖ User $userId joined as $role');
        
        // Trigger immediate participant refresh for better sync
        _loadRoomParticipants();
      } else if (status == 'left') {
        // User left - remove from unified manager
        _participantService.removeParticipant(userId);
        if (mounted) {
          setState(() {
            // Trigger UI update
          });
        }
        AppLogger().debug('üëã User $userId left the room');
        
        // Trigger immediate participant refresh for better sync
        _loadRoomParticipants();
      } else {
        // Role/status update - update existing participant
        _updateParticipantState(
          userId: userId,
          displayName: userName,
          avatarUrl: userAvatar,
          role: role,
        );
        
        // Check if THIS user just became a speaker and enable their microphone
        if (role == 'speaker' && userId == _currentUserId && _localParticipant != null) {
          AppLogger().info('üé§ Current user promoted to speaker - enabling microphone');
          _enableMicrophoneSimple();
        }
        
        // Check for hand raise notifications (only for moderators)
        if (role == 'pending' && userId != _currentUserId && _isCurrentUserModerator()) {
          AppLogger().info('üö® HAND RAISE DETECTED: $userId raised hand');
          _showHandRaiseNotificationFromPayload(payload);
        }
        
        AppLogger().debug('üîÑ User $userId updated to role: $role');
      }
    } catch (e) {
      AppLogger().error('‚ùå Error handling participant change: $e');
    }
  }
  
  /// Enable microphone when user becomes a speaker (server handles permissions)
  Future<void> _enableMicrophoneSimple() async {
    try {
      AppLogger().info('üé§ User promoted to speaker - enabling microphone');
      
      // Show immediate feedback
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('üé§ You\'re now a speaker! Enabling microphone...'),
            backgroundColor: Colors.blue,
            duration: Duration(seconds: 2),
          ),
        );
      }
      
      // Server-side permission update should have already granted publish permissions
      // We just need to enable the microphone locally
      if (_localParticipant != null) {
        await _localParticipant!.setMicrophoneEnabled(true);
        
        // Sync UI state with actual LiveKit state
        if (mounted) {
          _syncMuteState();
        }
        
        AppLogger().info('‚úÖ Microphone enabled for speaker');
        
        // Show success feedback
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('üé§ You can now speak! Your microphone is enabled.'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
        }
      } else {
        throw Exception('Local participant not available');
      }
    } catch (e) {
      AppLogger().error('‚ùå Failed to enable microphone for speaker: $e');
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to enable microphone. Please try again.'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () {
                _enableMicrophoneSimple();
              },
            ),
          ),
        );
      }
    }
  }


  void _updateParticipantsList() {
    if (_livekitRoom == null || !mounted) return;
    
    // Sync LiveKit participants with unified manager
    final allLiveKitParticipants = <lk.Participant>[
      if (_localParticipant != null) _localParticipant!,
      ..._livekitRoom!.remoteParticipants.values,
    ];
    
    for (final lkParticipant in allLiveKitParticipants) {
      final userId = lkParticipant.identity;
      final existing = _participantService.getParticipant(userId);
      
      // Determine audio state
      final isSpeaking = _isParticipantSpeaking(lkParticipant);
      final isMuted = lkParticipant is lk.LocalParticipant 
          ? _isMuted 
          : !lkParticipant.audioTrackPublications.any((track) => 
              track.track != null && !track.track!.muted);
      
      _updateParticipantState(
        userId: userId,
        isSpeaking: isSpeaking,
        isMuted: isMuted,
        liveKitParticipant: lkParticipant,
        displayName: existing?.displayName,
        avatarUrl: existing?.avatarUrl,
        role: existing?.role,
      );
    }
    
    // Update connection quality based on participant count
    setState(() {
      _totalParticipants = _participantService.totalCount;
      
      if (_totalParticipants > 20) {
        _connectionQuality = 'Fair';
      } else if (_totalParticipants > 10) {
        _connectionQuality = 'Good';
      } else {
        _connectionQuality = 'Excellent';
      }
    });
  }


  /// Load user profile and update participant state
  Future<void> _loadUserProfile(String userId) async {
    // Check if we already have this profile cached
    if (_userProfileCache.containsKey(userId)) {
      final cachedProfile = _userProfileCache[userId]!;
      _updateParticipantState(
        userId: userId,
        displayName: cachedProfile.displayName,
        avatarUrl: cachedProfile.avatar,
      );
      AppLogger().debug('üì∏ Using cached profile for $userId: ${cachedProfile.displayName}');
      return;
    }

    final existing = _participantService.getParticipant(userId);
    if (existing?.displayName != null && existing?.displayName != 'Unknown User') return;

    try {
      AppLogger().debug('üì∏ Loading profile for user: $userId');
      final profile = await _appwriteService.getUserProfile(userId);
      if (profile != null && mounted) {
        // Cache the profile
        _userProfileCache[userId] = profile;
        
        _updateParticipantState(
          userId: userId,
          displayName: profile.displayName,
          avatarUrl: profile.avatar,
        );
        AppLogger().debug('üì∏ Profile loaded and cached for $userId: avatar=${profile.avatar != null ? "YES" : "NO"}');
      } else {
        AppLogger().debug('üì∏ No profile found for user: $userId');
      }
    } catch (e) {
      AppLogger().debug('‚ö†Ô∏è Failed to load profile for $userId: $e');
    }
  }

  Future<void> _disconnectFromRoom() async {
    if (_isDisposing) return;
    
    AppLogger().debug('üö™ Starting room disconnection process');
    
    try {
      // Stop all timers first to prevent callbacks
      _reconnectTimer?.cancel();
      _heartbeatTimer?.cancel();
      
      // Disconnect using ConnectionManager
      await _connectionManager.disconnect();
      _livekitRoom = null;
      _localParticipant = null;
      _isConnected = false;
      
      // Remove user from Room Participants collection with retry
      if (_currentRoomId != null && _currentUserId != null) {
        for (int attempt = 1; attempt <= 3; attempt++) {
          try {
            await _openDiscussionService.removeRoomParticipant(
              roomId: _currentRoomId!,
              userId: _currentUserId!,
            ).timeout(const Duration(seconds: 10));
            AppLogger().debug('‚úÖ Successfully left Room Participants collection (attempt $attempt)');
            break;
          } catch (e) {
            AppLogger().warning('‚ö†Ô∏è Remove participant attempt $attempt failed: $e');
            if (attempt < 3) {
              await Future.delayed(Duration(milliseconds: 500 * attempt));
            }
          }
        }
      }

      // Clean up realtime participants subscription with timeout
      if (_realtimeParticipantsSubscription != null) {
        try {
          await _realtimeParticipantsSubscription!.close().timeout(const Duration(seconds: 3));
          _realtimeParticipantsSubscription = null;
          AppLogger().debug('‚úÖ Realtime participants subscription closed');
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Failed to close participants subscription: $e');
          _realtimeParticipantsSubscription = null; // Force null to prevent future issues
        }
      }
      
      // Clean up periodic refresh timer
      _participantRefreshTimer?.cancel();
      _participantRefreshTimer = null;
      
      // Clean up timer if moderator with timeout
      if (widget.userRole == 'moderator') {
        try {
          // Additional cleanup could be added here if needed
          AppLogger().debug('üßπ Timer cleanup - handled by Firebase automatically');
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Timer cleanup error: $e');
        }
      }
      
      // Reset connection state
      _reconnectAttempts = 0;
      
      AppLogger().info('‚úÖ Room disconnection completed successfully');
      
    } catch (e) {
      AppLogger().error('‚ùå Critical error during room disconnection: $e');
      
      // Force cleanup even if errors occurred
      _isConnected = false;
      _participantsSubscription = null;
      _reconnectTimer?.cancel();
      _heartbeatTimer?.cancel();
    }
  }

  // =====================================================
  // USER ACTIONS
  // =====================================================

  Future<void> _toggleMute() async {
    if (_isDisposing || !mounted) return;

    // Prevent double-toggling
    if (_isLoading) {
      AppLogger().debug('‚ö†Ô∏è Mute toggle already in progress');
      return;
    }

    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }

      final wasOriginallyMuted = _isMuted;
      
      // Use ConnectionManager for microphone control
      await _connectionManager.toggleMicrophone();
      
      // Update UI state to reflect actual LiveKit state
      if (mounted && _connectionManager.localParticipant != null) {
        final actualMicState = _connectionManager.localParticipant!.isMicrophoneEnabled();
        
        setState(() {
          _isMuted = !actualMicState; // If mic is enabled in LiveKit, we're not muted in UI
          _isLoading = false;
        });
        
        // Show brief success feedback
        final message = _isMuted ? 'üîá Microphone muted' : 'üé§ Microphone unmuted';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(message),
            duration: const Duration(seconds: 1),
            backgroundColor: _isMuted ? Colors.red.shade600 : Colors.green.shade600,
          ),
        );
      }
      
      AppLogger().info('‚úÖ Microphone ${_isMuted ? 'muted' : 'unmuted'} successfully');
      
    } catch (e) {
      _errorBoundary.handleLiveKitError(
        e,
        context: 'Toggle microphone mute',
      );
      
      if (mounted) {
        setState(() => _isLoading = false);
        
        // ErrorBoundary will handle user notification via error stream
        // But we can still provide immediate feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Failed to control microphone'),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => _toggleMute(),
            ),
          ),
        );
      }
    }
  }

  Future<void> _toggleHandRaise() async {
    if (_isDisposing || !mounted) return;
    
    AppLogger().debug('üöÄ _toggleHandRaise called');
    AppLogger().debug('üë§ Current user role: ${_getCurrentUserRole()}, ID: $_currentUserId');
    
    if (_isCurrentUserModerator() || _currentUserId == null) {
      AppLogger().debug('‚ùå Cannot toggle hand raise - user is moderator or no user ID');
      return;
    }

    // Prevent double-tapping
    if (_isLoading) {
      AppLogger().debug('‚ö†Ô∏è Hand raise toggle already in progress');
      return;
    }
    
    final isLowering = _hasCurrentUserRaisedHand();
    
    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }
      final roomIdToUse = _currentRoomId ?? widget.roomName;
      
      // Retry logic for hand raise/lower
      for (int attempt = 1; attempt <= 3; attempt++) {
        try {
          if (isLowering) {
            AppLogger().debug('‚¨áÔ∏è Lowering hand - updating role to audience (attempt $attempt)');
            await _appwriteService.updateRoomParticipantRole(
              roomId: roomIdToUse,
              userId: _currentUserId!,
              newRole: 'audience',
            ).timeout(const Duration(seconds: 10));
          } else {
            AppLogger().debug('üôã Raising hand - updating role to pending (attempt $attempt)');
            await _appwriteService.updateRoomParticipantRole(
              roomId: roomIdToUse,
              userId: _currentUserId!,
              newRole: 'pending',
            ).timeout(const Duration(seconds: 10));
          }
          
          // Success - break out of retry loop
          break;
          
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Hand raise attempt $attempt failed: $e');
          
          if (attempt == 3) {
            rethrow; // Last attempt failed
          }
          
          // Wait before retry with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
      }
      
      // Update loading state
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        
        // Show success feedback
        final message = isLowering 
            ? '‚úã Hand lowered - request cancelled'
            : '‚úã Hand raised - waiting for moderator approval';
        final color = isLowering ? Colors.grey : Colors.orange;
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(message),
            backgroundColor: color,
            duration: const Duration(seconds: 2),
          ),
        );
      }
      
      AppLogger().info('‚úÖ User ${_currentUserId!} ${isLowering ? 'lowered' : 'raised'} their hand');
      
    } catch (e) {
      AppLogger().error('‚ùå Error with hand raise/lower: $e');
      
      if (mounted) {
        setState(() => _isLoading = false);
        
        // Show user-friendly error message
        String errorMessage;
        if (e.toString().contains('timeout')) {
          errorMessage = 'Request timed out. Please check your connection and try again.';
        } else if (e.toString().contains('network') || e.toString().contains('connection')) {
          errorMessage = 'Network error. Please check your internet connection.';
        } else {
          errorMessage = 'Failed to ${isLowering ? 'lower' : 'raise'} hand. Please try again.';
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => _toggleHandRaise(),
            ),
          ),
        );
      }
    }
  }

  Future<void> _promoteToSpeaker(String participantIdentity) async {
    if (_isDisposing || !mounted || !_isCurrentUserModerator()) return;

    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }

      final roomIdToUse = _currentRoomId ?? widget.roomName;
      
      // Retry logic for speaker promotion
      for (int attempt = 1; attempt <= 3; attempt++) {
        try {
          AppLogger().debug('‚¨ÜÔ∏è Promoting $participantIdentity to speaker (attempt $attempt)');
          
          // Update the Appwrite role first
          await _appwriteService.updateRoomParticipantRole(
            roomId: roomIdToUse,
            userId: participantIdentity,
            newRole: 'speaker',
          ).timeout(const Duration(seconds: 10));
          
          // Also update LiveKit permissions via the service
          await _openDiscussionService.promoteToSpeaker(
            widget.roomName, 
            participantIdentity
          ).timeout(const Duration(seconds: 10));
          
          // Success - immediately update local participant state for instant UI feedback
          _participantService.updateParticipant(
            userId: participantIdentity,
            role: 'speaker',
          );
          
          // Remove from hand raises list if they were raising hand
          _handsRaised.remove(participantIdentity);
          
          // If this is the current user, enable their microphone immediately
          if (participantIdentity == _currentUserId && _localParticipant != null) {
            try {
              await _localParticipant!.setMicrophoneEnabled(true);
              _syncMuteState(); // Sync UI with actual LiveKit state
              AppLogger().debug('üé§ Microphone enabled for promoted speaker');
            } catch (e) {
              AppLogger().warning('‚ö†Ô∏è Failed to enable microphone: $e');
            }
          }
          
          // Success - break out of retry loop
          break;
          
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Speaker promotion attempt $attempt failed: $e');
          
          if (attempt == 3) {
            rethrow; // Last attempt failed
          }
          
          // Wait before retry with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
      }
      
      AppLogger().info('‚úÖ Successfully promoted $participantIdentity to speaker');
      
      // Force immediate participant refresh to update UI
      _loadRoomParticipants();
      
      // Update loading state
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        
        // Show success feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('üé§ Participant promoted to speaker'),
            backgroundColor: Colors.green.shade600,
            duration: const Duration(seconds: 2),
          ),
        );
      }
      
    } catch (e) {
      AppLogger().error('‚ùå Exception during promotion: $e');
      
      // Check if promotion actually succeeded despite the exception
      // Sometimes LiveKit or Appwrite operations succeed but still throw errors
      await Future.delayed(const Duration(milliseconds: 500)); // Brief delay for state propagation
      
      final participantData = _participantService.getParticipant(participantIdentity);
      final isNowSpeaker = participantData?.role == 'speaker';
      
      if (mounted) {
        setState(() => _isLoading = false);
        
        if (isNowSpeaker) {
          // Promotion actually succeeded, show success message instead
          AppLogger().info('‚úÖ Promotion succeeded despite exception: $participantIdentity is now a speaker');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('üé§ Participant promoted to speaker'),
              backgroundColor: Colors.green.shade600,
              duration: const Duration(seconds: 2),
            ),
          );
        } else {
          // Promotion actually failed, show error message
          AppLogger().error('‚ùå Promotion genuinely failed for: $participantIdentity');
          _errorBoundary.handleError(
            e,
            context: 'Promote participant to speaker',
            type: ErrorType.appwrite,
          );
          
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: const Text('Failed to promote participant'),
              backgroundColor: Colors.red,
              action: SnackBarAction(
                label: 'Retry',
                textColor: Colors.white,
                onPressed: () => _promoteToSpeaker(participantIdentity),
              ),
            ),
          );
        }
      }
    }
  }

  /// NEW: Unified promotion method using ParticipantPromotionService
  Future<void> _promoteToSpeakerUnified(String participantIdentity) async {
    if (_isDisposing || !mounted || !_isCurrentUserModerator()) return;

    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }

      final roomIdToUse = _currentRoomId ?? widget.roomName;
      
      // Use the unified promotion service for reliable promotion
      final success = await _promotionService.promoteToSpeaker(
        roomId: roomIdToUse,
        userId: participantIdentity,
        roomType: 'open_discussion',
      );
      
      if (success) {
        // Success - immediately update local participant state for instant UI feedback
        _participantService.updateParticipant(
          userId: participantIdentity,
          role: 'speaker',
        );
        
        // Remove from hand raises list if they were raising hand
        _handsRaised.remove(participantIdentity);
        
        // If this is the current user, refresh connection with new speaker permissions
        if (participantIdentity == _currentUserId) {
          try {
            AppLogger().info('üé§ Current user promoted to speaker - refreshing audio connection');
            
            // Force reconnection with new role to ensure proper permissions
            if (_connectionManager.isConnected) {
              await _connectionManager.disconnect();
              await Future.delayed(const Duration(milliseconds: 500)); // Brief pause for cleanup
            }
            
            // Reconnect with speaker permissions
            final reconnected = await _connectionManager.connect(
              roomName: widget.roomName,
              userId: _currentUserId!,
              displayName: _currentUserProfile?.name ?? _currentUserProfile?.email ?? 'Speaker',
              userRole: 'speaker',
            );
            
            if (reconnected) {
              // Give LiveKit a moment to fully establish permissions
              await Future.delayed(const Duration(milliseconds: 1000));
              
              // Ensure microphone is enabled for the newly promoted speaker
              if (_connectionManager.localParticipant != null) {
                try {
                  await _connectionManager.localParticipant!.setMicrophoneEnabled(true);
                  AppLogger().info('üé§ Explicitly enabled microphone for promoted speaker');
                } catch (e) {
                  AppLogger().error('‚ùå Failed to explicitly enable microphone: $e');
                }
              }
              
              _syncMuteState(); // Sync UI with actual LiveKit state
              AppLogger().info('‚úÖ Audio connection refreshed with speaker permissions');
              AppLogger().debug('üé§ Final microphone state - LiveKit enabled: ${_connectionManager.localParticipant?.isMicrophoneEnabled()}, UI muted: $_isMuted');
            } else {
              throw Exception('Failed to reconnect with speaker permissions');
            }
          } catch (e) {
            AppLogger().error('‚ùå Failed to refresh audio connection after promotion: $e');
            // Show error but don't fail the entire promotion
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text('‚ö†Ô∏è Promoted to speaker but audio needs refresh. Try clicking "Try Again".'),
                  backgroundColor: Colors.orange,
                  duration: const Duration(seconds: 4),
                ),
              );
            }
          }
        }
        
        AppLogger().info('‚úÖ Successfully promoted $participantIdentity to speaker');
        
        // Force immediate participant refresh to update UI
        _loadRoomParticipants();
        
        // Show success feedback
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('‚úÖ Participant promoted to speaker!'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 2),
            ),
          );
        }
      } else {
        throw Exception('Promotion service failed to promote participant');
      }
      
    } catch (e) {
      AppLogger().error('‚ùå Failed to promote participant to speaker: $e');
      
      // Show error feedback with retry button
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚ùå Failed to promote: ${e.toString()}'),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 4),
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => _promoteToSpeakerUnified(participantIdentity),
            ),
          ),
        );
      }
    } finally {
      // Update loading state
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  /// NEW: Unified hand raising using ParticipantPromotionService
  Future<void> _raiseHandUnified() async {
    if (_isDisposing || !mounted || _currentUserId == null) return;
    
    final roomIdToUse = _currentRoomId ?? widget.roomName;
    final displayName = _currentUserProfile?.name ?? _currentUserProfile?.email ?? 'Unknown User';
    
    final success = await _promotionService.raiseHand(
      roomId: roomIdToUse,
      userId: _currentUserId!,
      displayName: displayName,
    );
    
    if (success && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('‚úã Hand raised! Waiting for moderator approval...'),
          backgroundColor: Colors.blue,
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  Future<void> _denyHandRaise(String participantIdentity) async {
    if (_isDisposing || !mounted || !_isCurrentUserModerator()) return;

    // Prevent double-denial
    if (_isLoading) {
      AppLogger().debug('‚ö†Ô∏è Hand raise denial already in progress');
      return;
    }

    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }

      final roomIdToUse = _currentRoomId ?? widget.roomName;
      
      // Retry logic for hand raise denial
      for (int attempt = 1; attempt <= 3; attempt++) {
        try {
          AppLogger().debug('‚ùå Denying hand raise for $participantIdentity (attempt $attempt)');
          
          // Update the Appwrite role first  
          await _appwriteService.updateRoomParticipantRole(
            roomId: roomIdToUse,
            userId: participantIdentity,
            newRole: 'audience',
          ).timeout(const Duration(seconds: 10));
          
          // Also update via service for consistency
          await _openDiscussionService.lowerHand(
            widget.roomName, 
            participantIdentity
          ).timeout(const Duration(seconds: 10));
          
          // Success - break out of retry loop
          break;
          
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Hand raise denial attempt $attempt failed: $e');
          
          if (attempt == 3) {
            rethrow; // Last attempt failed
          }
          
          // Wait before retry with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
      }
      
      AppLogger().info('‚úÖ Successfully denied hand raise for $participantIdentity');
      
      // Update loading state
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
        
        // Show success feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('‚ùå Hand raise request denied'),
            backgroundColor: Colors.orange.shade600,
            duration: const Duration(seconds: 2),
          ),
        );
      }
      
    } catch (e) {
      AppLogger().error('‚ùå Failed to deny hand raise after all retries: $e');
      
      if (mounted) {
        setState(() => _isLoading = false);
        
        // Show user-friendly error message
        String errorMessage;
        if (e.toString().contains('timeout')) {
          errorMessage = 'Request timed out. Please check your connection and try again.';
        } else if (e.toString().contains('network') || e.toString().contains('connection')) {
          errorMessage = 'Network error. Please check your internet connection.';
        } else if (e.toString().contains('permission') || e.toString().contains('unauthorized')) {
          errorMessage = 'Permission denied. Please check your moderator privileges.';
        } else {
          errorMessage = 'Failed to deny hand raise request. Please try again.';
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => _denyHandRaise(participantIdentity),
            ),
          ),
        );
      }
    }
  }

  Future<void> _demoteToAudience(String participantIdentity) async {
    if (_isDisposing || !mounted || !_isCurrentUserModerator()) return;

    // Prevent double-demotion
    if (_isLoading) {
      AppLogger().debug('‚ö†Ô∏è Participant demotion already in progress');
      return;
    }

    try {
      // Show immediate UI feedback
      if (mounted) {
        setState(() => _isLoading = true);
      }
      
      // Retry logic for participant demotion
      for (int attempt = 1; attempt <= 3; attempt++) {
        try {
          AppLogger().debug('‚¨áÔ∏è Demoting $participantIdentity to audience (attempt $attempt)');
          
          await _openDiscussionService.demoteToAudience(
            widget.roomName, 
            participantIdentity
          ).timeout(const Duration(seconds: 10));
          
          // Success - break out of retry loop
          break;
          
        } catch (e) {
          AppLogger().warning('‚ö†Ô∏è Participant demotion attempt $attempt failed: $e');
          
          if (attempt == 3) {
            rethrow; // Last attempt failed
          }
          
          // Wait before retry with exponential backoff
          await Future.delayed(Duration(milliseconds: 500 * attempt));
        }
      }
      
      AppLogger().info('‚úÖ Successfully demoted $participantIdentity to audience');
      
      // Update local state
      if (mounted) {
        setState(() => _isLoading = false);
        
        // Show success feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('‚¨áÔ∏è Participant demoted to audience'),
            backgroundColor: Colors.blue.shade600,
            duration: const Duration(seconds: 2),
          ),
        );
      }
      
    } catch (e) {
      AppLogger().error('‚ùå Failed to demote participant after all retries: $e');
      
      if (mounted) {
        setState(() => _isLoading = false);
        
        // Show user-friendly error message
        String errorMessage;
        if (e.toString().contains('timeout')) {
          errorMessage = 'Demotion timed out. Please check your connection and try again.';
        } else if (e.toString().contains('network') || e.toString().contains('connection')) {
          errorMessage = 'Network error. Please check your internet connection.';
        } else if (e.toString().contains('permission') || e.toString().contains('unauthorized')) {
          errorMessage = 'Permission denied. Please check your moderator privileges.';
        } else {
          errorMessage = 'Failed to demote participant. Please try again.';
        }
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: 'Retry',
              textColor: Colors.white,
              onPressed: () => _demoteToAudience(participantIdentity),
            ),
          ),
        );
      }
    }
  }

  // =====================================================
  // UI HELPERS
  // =====================================================

  bool _isParticipantSpeaking(lk.Participant participant) {
    final audioTracks = participant.audioTrackPublications;
    return audioTracks.any((track) => track.track != null && track.track!.muted == false);
  }

  Map<String, dynamic> _getParticipantMetadata(lk.Participant participant) {
    try {
      return jsonDecode(participant.metadata ?? '{}');
    } catch (e) {
      AppLogger().warning('‚ö†Ô∏è Failed to parse participant metadata for ${participant.identity}: $e');
      return {};
    }
  }

  // =====================================================
  // CONNECTION HEALTH MONITORING
  // =====================================================

  String _getParticipantRole(lk.Participant participant) {
    final participantData = _participantService.getParticipant(participant.identity);
    if (participantData != null) {
      return participantData.role;
    }
    
    // Fallback to LiveKit metadata if not found in unified manager
    final metadata = _getParticipantMetadata(participant);
    return metadata['role'] ?? 'audience';
  }

  bool _isHandRaisedByParticipant(lk.Participant participant) {
    final participantData = _participantService.getParticipant(participant.identity);
    return participantData != null && participantData.isHandRaised;
  }

  /// Show room closed dialog when moderator closes the room
  void _showRoomClosedDialog(Map<String, dynamic> closureData) {
    if (!mounted) return;
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Row(
          children: [
            Icon(Icons.meeting_room, color: Colors.red),
            SizedBox(width: 8),
            Text('Room Closed'),
          ],
        ),
        content: IntrinsicHeight(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                closureData['message'] ?? 'This room has been closed by the moderator.',
                style: const TextStyle(fontSize: 16),
                maxLines: 3,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 8),
              Text(
                'You will be redirected to the home screen.',
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.grey[600],
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.of(context).pushAndRemoveUntil(
                MaterialPageRoute(builder: (context) => const OptimizedMainNavigator()),
                (route) => false,
              );
            },
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  void _showHandRaiseNotificationFromPayload(Map<String, dynamic> payload) async {
    try {
      AppLogger().info('üéØ _showHandRaiseNotificationFromPayload called with payload: $payload');
      final userId = payload['userId'];
      if (userId == null) {
        AppLogger().warning('‚ùå userId is null in payload');
        return;
      }
      
      AppLogger().info('üîç Getting user profile for: $userId');
      // Get user profile for the notification
      final userProfile = await _appwriteService.getUserProfile(userId);
      if (userProfile == null) {
        AppLogger().warning('‚ùå Could not find user profile for hand-raise notification: $userId');
        return;
      }
      
      AppLogger().info('‚úÖ Showing immediate hand-raise notification for: ${userProfile.displayName}');
      
      if (mounted) {
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (BuildContext context) {
            final screenHeight = MediaQuery.of(context).size.height;
            final isSmallScreen = screenHeight < 700;
            
            return Dialog(
              backgroundColor: Colors.grey[900],
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              insetPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 24),
              child: Container(
                padding: EdgeInsets.all(isSmallScreen ? 12 : 16),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Container(
                          padding: EdgeInsets.all(isSmallScreen ? 6 : 8),
                          decoration: BoxDecoration(
                            color: const Color(0xFF8B5CF6).withValues(alpha: 0.2),
                            shape: BoxShape.circle,
                          ),
                          child: const Icon(
                            Icons.pan_tool,
                            color: Color(0xFF8B5CF6),
                            size: 24,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                '${userProfile.displayName} raised their hand',
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                              Text(
                                'Would you like to promote them to speaker?',
                                style: TextStyle(
                                  color: Colors.grey[300],
                                  fontSize: 14,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                      children: [
                        Expanded(
                          child: TextButton(
                            onPressed: () {
                              Navigator.of(context).pop();
                              _denyHandRaise(userId);
                            },
                            style: TextButton.styleFrom(
                              backgroundColor: Colors.grey[800],
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8),
                              ),
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                            child: const Text(
                              'Deny',
                              style: TextStyle(color: Colors.white70),
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Expanded(
                          child: ElevatedButton(
                            onPressed: () {
                              Navigator.of(context).pop();
                              _promoteToSpeakerUnified(userId);
                            },
                            style: ElevatedButton.styleFrom(
                              backgroundColor: const Color(0xFF8B5CF6),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(8),
                              ),
                              padding: const EdgeInsets.symmetric(vertical: 12),
                            ),
                            child: const Text(
                              'Approve',
                              style: TextStyle(color: Colors.white),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            );
          },
        );
      }
    } catch (e) {
      AppLogger().error('Error showing hand-raise notification: $e');
    }
  }
  
  // =====================================================
  // TIMER MANAGEMENT
  // =====================================================
  
  // =====================================================
  // TIMER SYNCHRONIZATION LOGIC - CROSS-DEVICE
  // =====================================================
  
  Future<void> _initializeTimer() async {
    try {
      AppLogger().debug('‚è±Ô∏è Initializing timer for room: ${widget.roomName}');
      
      // Get current user ID for timer sync
      final user = await _appwriteService.getCurrentUser();
      if (user != null) {
        _currentAppwriteUserId = user.$id;
      }
      
      // Setup realtime subscription for timer sync
      _setupRealtimeSubscription();
      
      // Load initial timer state from database
      await _loadInitialTimerState();
      
    } catch (e) {
      AppLogger().error('‚ùå Failed to initialize timer: $e');
    }
  }
  
  // 1. REAL-TIME SUBSCRIPTION SETUP FOR TIMER SYNC
  void _setupRealtimeSubscription() {
    if (_reconnectAttempts >= _maxReconnectAttempts) {
      debugPrint('‚ùå Maximum realtime reconnection attempts reached. Operating in offline mode.');
      if (mounted) {
        setState(() {
          _isRealtimeHealthy = false;
        });
      }
      _startFallbackRefresh();
      return;
    }

    try {
      _realtimeSubscription?.cancel();
      
      debugPrint('üîÑ Setting up realtime subscription (attempt ${_reconnectAttempts + 1}/$_maxReconnectAttempts)');
      
      // Subscribe to room documents for timer state changes
      final realtimeChannel = _appwriteService.realtime.subscribe([
        'databases.${AppwriteConstants.databaseId}.collections.${AppwriteConstants.roomParticipantsCollection}.documents',
        'databases.${AppwriteConstants.databaseId}.collections.${AppwriteConstants.roomsCollection}.documents', // KEY: Timer state stored here
      ]);
      
      _realtimeSubscription = realtimeChannel.stream.listen(
        (response) {
          try {
            _reconnectAttempts = 0;
            
            if (!mounted) return;
            
            final payload = response.payload as Map;
            
            // Check if this update affects our room
            if (payload['roomId'] == widget.roomName) {
              debugPrint('üîÑ Refreshing participants for room update');
              
              if (!_isRealtimeHealthy && mounted) {
                setState(() {
                  _isRealtimeHealthy = true;
                });
                debugPrint('‚úÖ Realtime connection restored');
                _stopFallbackRefresh();
              }
              
              _loadRoomParticipants();
            }
            
            // KEY: Handle room document updates (including timer state)
            if (response.events.any((event) => event.contains('${AppwriteConstants.roomsCollection}.documents'))) {
              debugPrint('üè† Room document updated, checking for timer changes');
              _handleRoomDocumentUpdate(Map<String, dynamic>.from(payload));
            }
          } catch (e) {
            debugPrint('‚ùå Error processing room participant update: $e');
          }
        },
        onError: (error) {
          debugPrint('‚ùå Room participant subscription error: $error');
          _reconnectAttempts++;
          
          if (mounted) {
            setState(() {
              _isRealtimeHealthy = false;
            });
          }
          
          // Exponential backoff reconnection
          final delaySeconds = 2 << _reconnectAttempts.clamp(0, 5);
          
          if (_reconnectAttempts < _maxReconnectAttempts) {
            debugPrint('üîÑ Scheduling realtime reconnection in ${delaySeconds}s');
            
            Future.delayed(Duration(seconds: delaySeconds), () {
              if (mounted) {
                _setupRealtimeSubscription();
              }
            });
          }
          
          _startFallbackRefresh();
        },
      );
      
      debugPrint('üîî Real-time room subscription active for timer sync');
    } catch (e) {
      debugPrint('‚ùå Error setting up real-time subscription: $e');
      _reconnectAttempts++;
      
      if (mounted) {
        setState(() {
          _isRealtimeHealthy = false;
        });
      }
      
      _startFallbackRefresh();
    }
  }

  // 2. TIMER SYNC HANDLER - RECEIVES UPDATES FROM OTHER DEVICES
  void _handleRoomDocumentUpdate(Map<String, dynamic> payload) {
    try {
      // Only non-moderators should sync timer state from database
      if (_isCurrentUserModerator()) {
        debugPrint('üïê Ignoring timer update for moderator');
        return;
      }

      final settings = payload['settings'] as Map<String, dynamic>?;
      if (settings == null) return;

      final timerState = settings['timer'] as Map<String, dynamic>?;
      if (timerState == null) return;

      final updatedBy = timerState['updatedBy'] as String?;
      if (updatedBy == _currentAppwriteUserId) {
        debugPrint('üïê Ignoring timer update from self');
        return;
      }

      // KEY: Sync timer state from another device
      final newSpeakingTime = timerState['speakingTime'] as int? ?? 300;
      final isTimerRunning = timerState['isTimerRunning'] as bool? ?? false;
      final isTimerPaused = timerState['isTimerPaused'] as bool? ?? false;

      debugPrint('üïê Received timer update from moderator: ${newSpeakingTime}s, running: $isTimerRunning, paused: $isTimerPaused');

      if (mounted) {
        setState(() {
          _speakingTime = newSpeakingTime;
          _thirtySecondChimePlayed = false; // Reset chime for new timer state
        });
      }

      // Sync timer running state
      if (isTimerRunning && !isTimerPaused) {
        if (_speakingTimer == null || !_speakingTimer!.isActive) {
          _startLocalTimer();
        }
      } else {
        _speakingTimer?.cancel();
      }

    } catch (e) {
      debugPrint('‚ùå Error handling timer update: $e');
    }
  }

  // 3. INITIAL TIMER STATE LOADING FROM DATABASE
  Future<void> _loadInitialTimerState() async {
    try {
      // Get room document from discussion_rooms collection
      final roomData = await _appwriteService.databases.getDocument(
        databaseId: AppwriteConstants.databaseId,
        collectionId: AppwriteConstants.roomsCollection,
        documentId: widget.roomName, // Using roomName as document ID
      );

      final settings = roomData.data['settings'] as Map<String, dynamic>?;
      if (settings == null) return;

      final timerState = settings['timer'] as Map<String, dynamic>?;
      if (timerState == null) return;

      final speakingTime = timerState['speakingTime'] as int? ?? 300;
      final isRunning = timerState['isTimerRunning'] as bool? ?? false;
      final isPaused = timerState['isTimerPaused'] as bool? ?? false;

      debugPrint('üïê Loading initial timer state: ${speakingTime}s, running: $isRunning, paused: $isPaused');

      if (mounted) {
        setState(() {
          _speakingTime = speakingTime;
          _thirtySecondChimePlayed = false;
        });
      }

      // Start timer if it should be running
      if (isRunning && !isPaused) {
        _startLocalTimer();
      }

    } catch (e) {
      debugPrint('‚ö†Ô∏è Could not load initial timer state (might not exist yet): $e');
    }
  }

  // 4. MODERATOR TIMER UPDATE - PUSHES TO ALL DEVICES
  Future<void> _updateTimerInDatabase(int newTime, {bool? isRunning, bool? isPaused}) async {
    if (!_isCurrentUserModerator()) {
      debugPrint('‚ùå Only moderators can update timer');
      return;
    }

    try {
      final timerData = {
        'speakingTime': newTime,
        'isTimerRunning': isRunning ?? false,
        'isTimerPaused': isPaused ?? false,
        'updatedBy': _currentAppwriteUserId,
        'updatedAt': DateTime.now().toIso8601String(),
      };

      // Update room document with new timer state
      await _appwriteService.databases.updateDocument(
        databaseId: AppwriteConstants.databaseId,
        collectionId: AppwriteConstants.roomsCollection,
        documentId: widget.roomName,
        data: {
          'settings': {
            'timer': timerData,
          },
        },
      );

      debugPrint('‚úÖ Timer state updated in database: ${newTime}s, running: ${isRunning}, paused: ${isPaused}');
      
      // Real-time subscription will notify other devices automatically

    } catch (e) {
      debugPrint('‚ùå Error updating timer in database: $e');
    }
  }

  // 5. LOCAL TIMER WITH SYNC UPDATES
  void _startLocalTimer() {
    _speakingTimer?.cancel(); // Cancel existing timer
    
    _speakingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (!mounted) {
        timer.cancel();
        return;
      }
      
      if (_speakingTime > 0) {
        if (mounted) {
          setState(() {
            _speakingTime--;
            
            // Play chime at 30 seconds remaining (only once)
            if (_speakingTime == 30 && !_thirtySecondChimePlayed) {
              _thirtySecondChimePlayed = true;
              _playChimeSound();
            }
          });
        }
        
        // KEY: Moderators push timer updates to sync across devices
        if (_isCurrentUserModerator() && _speakingTime % 5 == 0) { // Update every 5 seconds
          _updateTimerInDatabase(_speakingTime, isRunning: true, isPaused: false);
        }
        
      } else {
        // Timer reached zero
        timer.cancel();
        _playBuzzerSound();
        
        // Update database that timer finished
        if (_isCurrentUserModerator()) {
          _updateTimerInDatabase(0, isRunning: false, isPaused: false);
        }
        
        if (mounted) {
          setState(() {});
          
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Timer finished! ‚è∞'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
        }
      }
    });
  }

  // 6. MODERATOR TIMER CONTROLS WITH SYNC
  Future<void> _pauseTimer() async {
    if (!_isCurrentUserModerator()) return;
    
    _speakingTimer?.cancel();
    
    // Update database to pause timer across all devices
    await _updateTimerInDatabase(_speakingTime, isRunning: true, isPaused: true);
    
    debugPrint('‚è∏Ô∏è Timer paused and synced across devices');
  }

  Future<void> _resumeTimer() async {
    if (!_isCurrentUserModerator()) return;
    
    // Start local timer
    _startLocalTimer();
    
    // Update database to resume timer across all devices
    await _updateTimerInDatabase(_speakingTime, isRunning: true, isPaused: false);
    
    debugPrint('‚ñ∂Ô∏è Timer resumed and synced across devices');
  }

  Future<void> _resetTimer({int newTime = 300}) async {
    if (!_isCurrentUserModerator()) return;
    
    _speakingTimer?.cancel();
    
    if (mounted) {
      setState(() {
        _speakingTime = newTime;
        _thirtySecondChimePlayed = false;
      });
    }
    
    // Update database to reset timer across all devices
    await _updateTimerInDatabase(newTime, isRunning: false, isPaused: false);
    
    debugPrint('üîÑ Timer reset to ${newTime}s and synced across devices');
  }

  Future<void> _startTimer() async {
    if (!_isCurrentUserModerator()) return;
    
    // Start local timer
    _startLocalTimer();
    
    // Update database to start timer across all devices
    await _updateTimerInDatabase(_speakingTime, isRunning: true, isPaused: false);
    
    debugPrint('‚ñ∂Ô∏è Timer started and synced across devices');
  }

  // 7. AUDIO PLAYBACK FOR TIMER
  void _playChimeSound() {
    // TODO: Implement audio playback for 30-second warning
    debugPrint('üîî Playing 30-second warning chime');
  }

  void _playBuzzerSound() {
    // TODO: Implement audio playback for timer expiration
    debugPrint('üîî Playing timer expiration buzzer');
  }

  // 8. FALLBACK REFRESH FOR OFFLINE TIMER SYNC
  void _startFallbackRefresh() {
    _fallbackRefreshTimer?.cancel();
    
    if (!_isRealtimeHealthy && mounted) {
      debugPrint('üîÑ Starting fallback refresh timer (every 30 seconds) for timer sync');
      
      _fallbackRefreshTimer = Timer.periodic(const Duration(seconds: 30), (timer) {
        if (!mounted) {
          timer.cancel();
          return;
        }
        
        if (!_isRealtimeHealthy) {
          debugPrint('üîÑ Fallback refresh: syncing timer state');
          _loadInitialTimerState(); // Re-sync timer from database
          _loadRoomParticipants();
        } else {
          debugPrint('‚úÖ Realtime restored, stopping fallback refresh');
          timer.cancel();
        }
      });
    }
  }

  void _stopFallbackRefresh() {
    _fallbackRefreshTimer?.cancel();
    _fallbackRefreshTimer = null;
    debugPrint('üõë Stopped fallback refresh timer');
  }
  
  // =====================================================
  // UI HELPERS
  // =====================================================
  
  List<ParticipantData> _getSpeakers() {
    // Only return participants with 'speaker' role, exclude moderators
    return _participantService.all.where((p) => p.role == 'speaker').toList();
  }
  
  List<ParticipantData> _getAudience() {
    return _participantService.all.where((p) => p.role != 'moderator' && p.role != 'speaker').toList();
  }
  
  List<lk.Participant> _getAllParticipants() {
    final allParticipants = <lk.Participant>[
      if (_localParticipant != null) _localParticipant!,
      ..._livekitRoom?.remoteParticipants.values.toList() ?? [],
    ];
    return allParticipants;
  }

  // =====================================================
  // CHAT PANEL HELPERS
  // =====================================================
  
  
  IconData _getConnectionIcon() {
    switch (_connectionQuality.toLowerCase()) {
      case 'excellent':
        return Icons.signal_wifi_4_bar;
      case 'good':
        return Icons.signal_wifi_4_bar;
      case 'fair':
        return Icons.network_wifi_2_bar;
      case 'poor':
        return Icons.signal_wifi_bad;
      default:
        return Icons.signal_wifi_off;
    }
  }
  
  Color _getConnectionColor() {
    switch (_connectionQuality.toLowerCase()) {
      case 'excellent':
        return Colors.green;
      case 'good':
        return const Color(0xFF4CAF50);
      case 'fair':
        return Colors.orange;
      case 'poor':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }
  
  
  // =====================================================
  // UI BUILD
  // =====================================================

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: false, // Prevent automatic pop, handle it manually
      onPopInvokedWithResult: (didPop, result) async {
        if (!didPop) {
          // Handle back button press - ensure proper cleanup
          debugPrint('üö™ User attempting to leave room via back button - performing cleanup');
          await _leaveRoomData(); // Ensure LiveKit disconnect and room cleanup
          if (context.mounted) {
            Navigator.of(context).pop(); // Now actually leave
          }
        }
      },
      child: Scaffold(
        body: Stack(
          children: [
            // Main room interface
            Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.white,
                    scarletRed.withValues(alpha: 0.05),
                    accentPurple.withValues(alpha: 0.1),
                  ],
                ),
              ),
              child: SafeArea(
                child: Column(
                  children: [
                    // Header with room info and controls
                    _buildHeader(),
                    
                    // Main content area
                    Expanded(
                      child: SingleChildScrollView(
                        padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // Moderator section
                            _buildModeratorSection(),
                            
                            const SizedBox(height: 24),
                            
                            // Speaker's panel (8-slot grid)
                            _buildSpeakersPanel(),
                            
                            const SizedBox(height: 24),
                            
                            // Audience section
                            _buildAudienceSection(),
                            
                            // Extra bottom padding
                            const SizedBox(height: 80),
                          ],
                        ),
                      ),
                    ),
                    
                    // Bottom controls
                    _buildBottomControls(),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Header Navigation for Open Discussion Room
  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border(
          bottom: BorderSide(
            color: scarletRed.withValues(alpha: 0.1),
            width: 1,
          ),
        ),
        boxShadow: [
          BoxShadow(
            color: scarletRed.withValues(alpha: 0.05),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          // Leave room button (door exit icon)
          GestureDetector(
            onTap: _leaveRoom,
            child: Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: scarletRed.withValues(alpha: 0.1),
                borderRadius: const BorderRadius.all(Radius.circular(6)),
                border: Border.all(
                  color: scarletRed.withValues(alpha: 0.3),
                ),
              ),
              child: const Icon(
                Icons.exit_to_app,
                color: scarletRed,
                size: 16,
              ),
            ),
          ),
          
          const SizedBox(width: 8),
          
          // Room info (left side)
          Expanded(
            flex: 3,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _roomDisplayTitle.isNotEmpty ? _roomDisplayTitle : widget.roomName,
                  style: const TextStyle(
                    color: deepPurple,
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                Row(
                  children: [
                    // Room participants count
                    Container(
                      width: 4,
                      height: 4,
                      decoration: const BoxDecoration(
                        color: Colors.green,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 2),
                    Flexible(
                      child: Text(
                        '${_participants.length} in room (${_remoteStreams.length + (_isAudioConnected ? 1 : 0)} audio)',
                        style: const TextStyle(
                          color: accentPurple,
                          fontSize: 8,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    
                    // Realtime sync status
                    const SizedBox(width: 2),
                    Container(
                      width: 3,
                      height: 3,
                      decoration: BoxDecoration(
                        color: _isRealtimeHealthy ? Colors.green : Colors.red,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 1),
                    Text(
                      _isRealtimeHealthy ? 'sync' : 'offline',
                      style: TextStyle(
                        color: _isRealtimeHealthy ? Colors.green : Colors.red,
                        fontSize: 6,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          
          const SizedBox(width: 4),
          
          // Centered Timer
          Expanded(
            flex: 3,
            child: Center(
              child: AppwriteTimerWidget(
                roomId: widget.roomName, // Use roomName as roomId
                roomType: timer_models.RoomType.openDiscussion,
                isModerator: _isCurrentUserModerator(),
                userId: _currentUserId ?? '',
                compact: true,
                showControls: true, // Allow all users to access timer controls in open discussions
                showConnectionStatus: false,
              ),
            ),
          ),
          
          const SizedBox(width: 2),
          
          // Right side controls
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Room count icon
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 1),
                decoration: BoxDecoration(
                  color: accentPurple.withValues(alpha: 0.1),
                  borderRadius: const BorderRadius.all(Radius.circular(4)),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(
                      Icons.people,
                      color: accentPurple,
                      size: 8,
                    ),
                    const SizedBox(width: 1),
                    Text(
                      '${_participants.length}',
                      style: const TextStyle(
                        color: accentPurple,
                        fontSize: 7,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ],
                ),
              ),
              
              const SizedBox(width: 4),
              
              // Instant Message Bell
              const InstantMessageBell(
                iconColor: Color(0xFF8B5CF6),
                iconSize: 16,
              ),
              
              const SizedBox(width: 4),
              
              // Challenge Bell
              const ChallengeBell(
                iconColor: Color(0xFFFF2400),
                iconSize: 16,
              ),
              
              const SizedBox(width: 4),
              
              // Moderation controls (only for moderators)
              if (_isCurrentUserModerator())
                Stack(
                  children: [
                    Stack(
                      children: [
                        Container(
                          decoration: BoxDecoration(
                            color: scarletRed.withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: scarletRed.withValues(alpha: 0.3),
                              width: 1,
                            ),
                          ),
                          child: IconButton(
                            onPressed: _showModerationModal,
                            icon: const Icon(
                              Icons.admin_panel_settings,
                              color: scarletRed,
                              size: 24,
                            ),
                            tooltip: 'Moderator Tools',
                            padding: const EdgeInsets.all(8),
                            constraints: const BoxConstraints(
                              minWidth: 40,
                              minHeight: 40,
                            ),
                          ),
                        ),
                        // Notification badge for hands raised
                        if (_participantService.pendingRequests.isNotEmpty)
                          Positioned(
                            right: 0,
                            top: 0,
                            child: Container(
                              padding: const EdgeInsets.all(4),
                              decoration: const BoxDecoration(
                                color: Colors.orange,
                                shape: BoxShape.circle,
                              ),
                              constraints: const BoxConstraints(
                                minWidth: 16,
                                minHeight: 16,
                              ),
                              child: Text(
                                _participantService.pendingRequests.length.toString(),
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                ),
                                textAlign: TextAlign.center,
                              ),
                            ),
                          ),
                      ],
                    ),
                  ],
                ),
              
              // Connection status indicator
              if (_isReconnecting) ...[
                const SizedBox(width: 4),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.orange.withValues(alpha: 0.2),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: const Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      SizedBox(
                        width: 12,
                        height: 12,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          valueColor: AlwaysStoppedAnimation<Color>(Colors.orange),
                        ),
                      ),
                      SizedBox(width: 4),
                      Text(
                        'Reconnecting...',
                        style: TextStyle(
                          color: Colors.orange,
                          fontSize: 10,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ],
          ),
        ],
      ),
    );
  }

  // MODERATOR SECTION
  Widget _buildModeratorSection() {
    final moderator = _getModerator();
    if (moderator == null) return const SizedBox();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Room Moderator',
          style: TextStyle(
            color: deepPurple,
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 15),
        Center(
          child: _buildUserAvatar(
            participant: moderator,
            size: 100,
            showModerator: true,
          ),
        ),
      ],
    );
  }

  // SPEAKERS PANEL (8-slot grid)
  Widget _buildSpeakersPanel() {
    final speakers = _getSpeakers();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Speakers (${speakers.length})',
          style: const TextStyle(
            color: deepPurple,
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 15),
        
        if (speakers.isEmpty)
          Center(
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Text(
                'No speakers yet.\nRaise your hand to become a speaker!',
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: deepPurple.withValues(alpha: 0.6),
                  fontSize: 14,
                ),
              ),
            ),
          )
        else
          // Two rows of speakers (4 per row) = 8 total slots
          for (int i = 0; i < 2; i++)
            Padding(
              padding: const EdgeInsets.only(bottom: 15),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  for (int j = 0; j < 4; j++)
                    if (i * 4 + j < speakers.length) ...[
                      _buildUserAvatar(
                        participant: speakers[i * 4 + j],
                        size: 60,
                      ),
                    ] else
                      _buildEmptySpeakerSlot(),
                ],
              ),
            ),
      ],
    );
  }

  // AUDIENCE SECTION
  Widget _buildAudienceSection() {
    final audience = _getAudience();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text(
              'Audience (${audience.length})',
              style: const TextStyle(
                color: deepPurple,
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
            // Show hands raised count for moderators
            if (_isCurrentUserModerator() && _participantService.pendingRequests.isNotEmpty) ...[
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.orange.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(10),
                  border: Border.all(color: Colors.orange),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(Icons.pan_tool, size: 12, color: Colors.orange),
                    const SizedBox(width: 4),
                    Text(
                      '${_participantService.pendingRequests.length}',
                      style: const TextStyle(
                        color: Colors.orange,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ],
        ),
        const SizedBox(height: 15),
        
        if (audience.isEmpty)
          Center(
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Text(
                'No audience members yet.\nInvite friends to join the discussion!',
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: deepPurple.withValues(alpha: 0.6),
                  fontSize: 14,
                ),
              ),
            ),
          )
        else
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              crossAxisSpacing: 15,
              mainAxisSpacing: 15,
              childAspectRatio: 1,
            ),
            itemCount: audience.length,
            itemBuilder: (context, index) {
              return _buildUserAvatar(
                participant: audience[index],
                size: 50,
              );
            },
          ),
      ],
    );
  }

  // USER AVATAR BUILDER
  Widget _buildUserAvatar({
    required ParticipantData participant,
    required double size,
    bool showModerator = false,
  }) {
    final isCurrentUser = participant.id == _currentUserId;
    final userProfile = _userProfileCache[participant.id];
    
    String displayName;
    if (isCurrentUser) {
      displayName = 'You';
    } else if (userProfile != null) {
      displayName = userProfile.displayName;
    } else {
      displayName = participant.displayName;
    }
    
    return GestureDetector(
      onTap: userProfile != null ? () => _showUserProfile(userProfile, participant.role) : null,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Stack(
            children: [
              Container(
                width: size,
                height: size,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: (participant.isSpeaking ? scarletRed : accentPurple).withValues(alpha: 0.2),
                      blurRadius: participant.isSpeaking ? 8 : 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: CircleAvatar(
                  radius: size / 2,
                  backgroundColor: accentPurple.withValues(alpha: 0.2),
                  backgroundImage: userProfile?.avatar != null 
                    ? NetworkImage(userProfile!.avatar!) 
                    : null,
                  child: userProfile?.avatar == null 
                    ? Text(
                        userProfile?.initials ?? 
                          (isCurrentUser ? 'YOU' : participant.displayName.isNotEmpty 
                            ? participant.displayName.substring(0, 2).toUpperCase()
                            : participant.id.substring(0, 2).toUpperCase()),
                        style: TextStyle(
                          color: deepPurple,
                          fontSize: size * 0.3,
                          fontWeight: FontWeight.bold,
                        ),
                      )
                    : null,
                ),
              ),
              
              // Hand raised indicator (show for current user or if current user is moderator)
              if (participant.isHandRaised && (isCurrentUser || _isCurrentUserModerator()))
                Positioned(
                  top: 0,
                  right: 0,
                  child: Container(
                    width: size * 0.3,
                    height: size * 0.3,
                    decoration: const BoxDecoration(
                      color: scarletRed,
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black26,
                          blurRadius: 2,
                          offset: Offset(0, 1),
                        ),
                      ],
                    ),
                    child: Icon(
                      Icons.pan_tool,
                      size: size * 0.2,
                      color: Colors.white,
                    ),
                  ),
                ),
            ],
          ),
          
          const SizedBox(height: 6),
          
          // User name and status
          SizedBox(
            width: size + 10,
            child: Column(
              children: [
                Text(
                  displayName,
                  textAlign: TextAlign.center,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(
                    color: isCurrentUser ? scarletRed : deepPurple,
                    fontSize: size > 60 ? 12 : 10,
                    fontWeight: isCurrentUser ? FontWeight.bold : FontWeight.w500,
                  ),
                ),
                
                // Status badges
                if (showModerator)
                  Container(
                    margin: const EdgeInsets.only(top: 2),
                    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: const BoxDecoration(
                      color: scarletRed,
                      borderRadius: BorderRadius.all(Radius.circular(8)),
                    ),
                    child: const Text(
                      'MODERATOR',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 8,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  )
                else if (participant.isSpeaking)
                  Container(
                    margin: const EdgeInsets.only(top: 2),
                    padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
                    decoration: const BoxDecoration(
                      color: Colors.green,
                      borderRadius: BorderRadius.all(Radius.circular(6)),
                    ),
                    child: const Text(
                      'LIVE',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 7,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildEmptySpeakerSlot() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 60,
          height: 60,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            border: Border.all(
              color: accentPurple.withValues(alpha: 0.3),
              width: 2,
              style: BorderStyle.solid,
            ),
            color: lightScarlet,
          ),
          child: Icon(
            Icons.gavel,
            size: 30,
            color: accentPurple.withValues(alpha: 0.6),
          ),
        ),
        const SizedBox(height: 5),
        Text(
          'Open',
          style: TextStyle(
            color: deepPurple.withValues(alpha: 0.6),
            fontSize: 10,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  // BOTTOM CONTROLS
  Widget _buildBottomControls() {
    return Container(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border(
          top: BorderSide(
            color: scarletRed.withValues(alpha: 0.1),
            width: 1,
          ),
        ),
        boxShadow: [
          BoxShadow(
            color: scarletRed.withValues(alpha: 0.05),
            blurRadius: 10,
            offset: const Offset(0, -2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Status text
          Text(
            _getCurrentUserRole() == 'moderator'
              ? 'üëë You are the moderator'
              : _getCurrentUserRole() == 'speaker'
                ? 'üéôÔ∏è You are a speaker'
                : 'üëÇ You are in the audience${_isCurrentUserHandRaised() ? ' ‚Ä¢ Hand raised' : ''}',
            style: TextStyle(
              color: _getCurrentUserRole() == 'moderator'
                ? Colors.green
                : _getCurrentUserRole() == 'speaker'
                  ? Colors.green
                  : accentPurple,
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              // Chat
              _buildControlButton(
                icon: Icons.chat_bubble,
                label: 'Chat',
                color: accentPurple,
                onTap: _toggleChatPanel,
              ),
              
              // Audio
              _buildControlButton(
                icon: !_isConnected 
                  ? (_connectionManager.status == LiveKitConnectionStatus.connecting ? Icons.hourglass_empty : Icons.speaker)
                  : (_getCurrentUserRole() != 'moderator' && _getCurrentUserRole() != 'speaker') 
                    ? Icons.speaker_notes_off
                    : (_isMuted ? Icons.volume_off : Icons.volume_up),
                label: !_isConnected 
                  ? (_connectionManager.status == LiveKitConnectionStatus.connecting ? 'Connecting...' : 'Join Audio')
                  : (_getCurrentUserRole() != 'moderator' && _getCurrentUserRole() != 'speaker') 
                    ? 'No Mic Access'
                    : (_isMuted ? 'Muted' : 'Audio On'),
                color: !_isConnected 
                  ? (_connectionManager.status == LiveKitConnectionStatus.connecting ? Colors.orange : Colors.blue)
                  : (_getCurrentUserRole() != 'moderator' && _getCurrentUserRole() != 'speaker') 
                    ? Colors.grey
                    : (_isMuted ? Colors.red : Colors.green),
                onTap: _handleAudioTap,
              ),
              
              // Hand raise (only show for non-moderators)
              if (_getCurrentUserRole() != 'moderator')
                _buildControlButton(
                  icon: _isCurrentUserHandRaised() ? Icons.back_hand : Icons.back_hand_outlined,
                  label: _getCurrentUserRole() == 'speaker'
                    ? 'Leave Panel'
                    : (_isCurrentUserHandRaised() ? 'Lower' : 'Raise'),
                  color: _getCurrentUserRole() == 'speaker' 
                    ? scarletRed 
                    : _isCurrentUserHandRaised() ? scarletRed : accentPurple,
                  onTap: _toggleHandRaise,
                ),
              
              // Gift
              _buildControlButton(
                icon: Icons.card_giftcard,
                label: 'Gift',
                color: Colors.amber,
                onTap: _showGiftModal,
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildControlButton({
    required IconData icon,
    required String label,
    required Color color,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 40,
            height: 40,
            decoration: BoxDecoration(
              color: lightScarlet,
              borderRadius: const BorderRadius.all(Radius.circular(20)),
              border: Border.all(
                color: color.withValues(alpha: 0.3),
                width: 1,
              ),
              boxShadow: [
                BoxShadow(
                  color: color.withValues(alpha: 0.2),
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Icon(
              icon,
              color: color,
              size: 20,
            ),
          ),
          const SizedBox(height: 3),
          Text(
            label,
            style: TextStyle(
              color: color,
              fontSize: 10,
              fontWeight: FontWeight.w500,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }

  // GETTER METHODS - Use existing methods and add missing ones
  ParticipantData? _getModerator() {
    try {
      return _participantService.all.firstWhere((p) => p.role == 'moderator');
    } catch (e) {
      return null;
    }
  }

  bool _isCurrentUserHandRaised() {
    if (_currentUserId == null) return false;
    final participant = _participantService.getParticipant(_currentUserId!);
    return participant?.isHandRaised ?? false;
  }

  int _getHandsRaisedCount() {
    return _participantService.all.where((p) => p.isHandRaised).length;
  }

  // HANDLER METHODS - Connect to existing functionality
  void _showNotificationModal(String type) {
    // Use existing notification functionality
    AppLogger().debug('Show notification modal: $type');
  }

  void _showUserProfileModal(UserProfile? profile, String userId) {
    // Use existing user profile functionality
    AppLogger().debug('Show user profile: $userId');
  }

  void _toggleChatPanel() {
    final currentUser = _getCurrentUserProfile();
    if (currentUser == null) return;
    
    // Convert participants to chat participants format
    final chatParticipants = _participants.map((p) {
      final userProfile = _userProfileCache[p['userId']];
      return ChatParticipant(
        userId: p['userId'],
        username: userProfile?.name ?? 'Unknown User',
        role: p['role'],
        avatar: userProfile?.avatar,
        isOnline: true,
        joinedAt: DateTime.now(),
      );
    }).toList();
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      enableDrag: true,
      isDismissible: true,
      builder: (context) => MattermostChatWidget(
        currentUserId: _currentUserId!,
        currentUser: currentUser,
        roomId: widget.roomName,
        participants: chatParticipants,
        onClose: () {
          // Dismiss keyboard first, then close modal
          FocusScope.of(context).unfocus();
          Navigator.of(context).pop();
        },
      ),
    );
  }

  /// Get current user profile for chat
  UserProfile? _getCurrentUserProfile() {
    if (_currentUserId == null) return null;
    return _userProfileCache[_currentUserId!] ?? _currentUserProfile;
  }

  void _handleAudioTap() async {
    if (_isConnected) {
      try {
        // Check if user has speaker permissions
        final currentRole = _getCurrentUserRole();
        if (currentRole != 'moderator' && currentRole != 'speaker') {
          AppLogger().warning('‚ö†Ô∏è Cannot toggle microphone: user is not a speaker or moderator');
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You need to be a speaker to use the microphone. Raise your hand to request speaking permissions.'),
              backgroundColor: Colors.orange,
            ),
          );
          return;
        }
        
        await _connectionManager.toggleMicrophone();
        
        // Update UI state to reflect actual LiveKit state (same logic as _toggleMute)
        if (mounted && _connectionManager.localParticipant != null) {
          final actualMicState = _connectionManager.localParticipant!.isMicrophoneEnabled();
          
          setState(() {
            _isMuted = !actualMicState; // If mic is enabled in LiveKit, we're not muted in UI
          });
          
          AppLogger().debug('üé§ Audio tap: LiveKit mic enabled: $actualMicState, UI muted: $_isMuted');
          
          // Show user feedback
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(_isMuted ? 'üîá Microphone muted' : 'üé§ Microphone unmuted'),
              duration: const Duration(seconds: 1),
              backgroundColor: _isMuted ? Colors.red : Colors.green,
            ),
          );
        }
      } catch (e) {
        AppLogger().error('‚ùå Failed to handle audio tap: $e');
        
        // Show user-friendly error message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Failed to toggle microphone: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    } else {
      // Try to connect to audio
      AppLogger().debug('Attempting to connect to audio');
    }
  }

  /// Helper method to sync UI mute state with actual LiveKit state
  void _syncMuteState() {
    if (_connectionManager.localParticipant != null) {
      final actualMicState = _connectionManager.localParticipant!.isMicrophoneEnabled();
      final shouldBeMuted = !actualMicState;
      
      if (_isMuted != shouldBeMuted) {
        setState(() {
          _isMuted = shouldBeMuted;
        });
        AppLogger().debug('üîÑ Synced mute state: LiveKit enabled: $actualMicState, UI muted: $_isMuted');
      }
    }
  }

  // Missing methods that are referenced in the existing code
  Future<void> _loadFirebaseCoinBalance() async {
    if (_currentUserId == null) return;
    
    try {
      final balance = await _firebaseGiftService.getUserCoinBalance(_currentUserId!);
      if (mounted) {
        setState(() {
          _currentUserCoinBalance = balance;
        });
        AppLogger().debug('ü™ô Updated Firebase coin balance: $balance');
      }
    } catch (e) {
      AppLogger().error('‚ùå Failed to load Firebase coin balance: $e');
    }
  }

  void _forceDisconnectFromRoom() {
    // Implementation for force disconnect
  }
  
  // =====================================================
  // ROOM CLOSING AND LEAVING LOGIC
  // =====================================================
  
  // Leave room with data cleanup
  Future<void> _leaveRoomData() async {
    try {
      // Disconnect from LiveKit before leaving room
      if (_connectionManager.isConnected) {
        await _connectionManager.disconnect();
        debugPrint('üîå Disconnected from LiveKit room');
      }
      
      // Remove user from room participants
      if (_currentUserId != null && widget.roomName.isNotEmpty) {
        try {
          await _openDiscussionService.removeRoomParticipant(
            roomId: widget.roomName,
            userId: _currentUserId!,
          );
          debugPrint('‚úÖ Left room ${widget.roomName}');
        } catch (e) {
          debugPrint('‚ö†Ô∏è Error removing from room participants: $e');
        }
      }
    } catch (e) {
      debugPrint('‚ùå Error leaving room: $e');
    }
  }
  
  // Leave room function (called when user exits)
  Future<void> _leaveRoom() async {
    await _leaveRoomData();
    if (mounted) {
      Navigator.of(context).pop();
    }
  }
  
  void _showModerationModal() {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (BuildContext context) {
        return Container(
          height: MediaQuery.of(context).size.height * 0.8,
          decoration: const BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: Column(
            children: [
              // Handle bar
              Container(
                margin: const EdgeInsets.only(top: 8),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey[300],
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              
              // Header
              Padding(
                padding: const EdgeInsets.all(20),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: scarletRed.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(
                        Icons.admin_panel_settings,
                        color: scarletRed,
                        size: 24,
                      ),
                    ),
                    const SizedBox(width: 12),
                    const Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            'Moderator Controls',
                            style: TextStyle(
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                              color: darkGray,
                            ),
                          ),
                          Text(
                            'Manage participants and room settings',
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey,
                            ),
                          ),
                        ],
                      ),
                    ),
                    IconButton(
                      onPressed: () => Navigator.of(context).pop(),
                      icon: const Icon(Icons.close),
                    ),
                  ],
                ),
              ),
              
              // Content
              Expanded(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _buildHandRaisedSection(),
                      const SizedBox(height: 24),
                      _buildAudioControlsSection(),
                      const SizedBox(height: 24),
                      _buildQuickActionsSection(),
                      const SizedBox(height: 24),
                      _buildUserManagementSection(),
                      const SizedBox(height: 20),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildHandRaisedSection() {
    final pendingRequests = _participantService.pendingRequests;
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: accentPurple.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(6),
              ),
              child: const Icon(
                Icons.pan_tool,
                color: accentPurple,
                size: 18,
              ),
            ),
            const SizedBox(width: 8),
            const Text(
              'Hand Raised',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: darkGray,
              ),
            ),
            if (pendingRequests.isNotEmpty) ...[
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: scarletRed,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  pendingRequests.length.toString(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ],
        ),
        const SizedBox(height: 12),
        
        if (pendingRequests.isEmpty)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey[50],
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.grey[200]!),
            ),
            child: const Column(
              children: [
                Icon(Icons.check_circle, color: Colors.green, size: 32),
                SizedBox(height: 8),
                Text(
                  'No hands raised',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                    color: Colors.grey,
                  ),
                ),
              ],
            ),
          )
        else
          ...pendingRequests.map((participant) => Container(
            margin: const EdgeInsets.only(bottom: 8),
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: lightScarlet,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: scarletRed.withValues(alpha: 0.2)),
            ),
            child: Row(
              children: [
                UserAvatar(
                  avatarUrl: participant.avatarUrl,
                  initials: participant.displayName.isNotEmpty ? participant.displayName[0].toUpperCase() : '?',
                  radius: 18,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        participant.displayName,
                        style: const TextStyle(
                          fontSize: 14,
                          fontWeight: FontWeight.w600,
                          color: darkGray,
                        ),
                      ),
                      Text(
                        'Wants to speak ‚Ä¢ ${_formatTimestamp(DateTime.now())}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                    ],
                  ),
                ),
                ElevatedButton(
                  onPressed: () => _promoteToSpeakerUnified(participant.id),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: accentPurple,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                  child: const Text('Promote', style: TextStyle(fontSize: 12)),
                ),
              ],
            ),
          )).toList(),
      ],
    );
  }

  Widget _buildAudioControlsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: Colors.blue.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(6),
              ),
              child: const Icon(
                Icons.audiotrack,
                color: Colors.blue,
                size: 18,
              ),
            ),
            const SizedBox(width: 8),
            const Text(
              'Audio Controls',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: darkGray,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: Colors.grey[200]!),
          ),
          child: Column(
            children: [
              Row(
                children: [
                  Container(
                    width: 8,
                    height: 8,
                    decoration: BoxDecoration(
                      color: _isAudioConnected ? Colors.green : Colors.red,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    _isAudioConnected ? 'Audio Connected' : 'Audio Disconnected',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w500,
                      color: _isAudioConnected ? Colors.green[700] : Colors.red[700],
                    ),
                  ),
                  const Spacer(),
                  _buildFeatureChip('Live', Colors.green),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  const Icon(Icons.signal_cellular_alt, size: 16, color: Colors.grey),
                  const SizedBox(width: 8),
                  const Text(
                    'Connection Quality',
                    style: TextStyle(fontSize: 14, color: Colors.grey),
                  ),
                  const Spacer(),
                  _buildFeatureChip('Excellent', Colors.green),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  const Icon(Icons.noise_control_off, size: 16, color: Colors.grey),
                  const SizedBox(width: 8),
                  const Text(
                    'Noise Cancellation',
                    style: TextStyle(fontSize: 14, color: Colors.grey),
                  ),
                  const Spacer(),
                  _buildFeatureChip('Active', accentPurple),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildQuickActionsSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: Colors.orange.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(6),
              ),
              child: const Icon(
                Icons.speed,
                color: Colors.orange,
                size: 18,
              ),
            ),
            const SizedBox(width: 8),
            const Text(
              'Quick Actions',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: darkGray,
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        
        Row(
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _muteAllParticipants,
                icon: const Icon(Icons.volume_off, size: 18),
                label: const Text('Mute All'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _closeRoom,
                icon: const Icon(Icons.close, size: 18),
                label: const Text('Close Room'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: scarletRed,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildUserManagementSection() {
    final allParticipants = _participantService.all;
    final speakers = allParticipants.where((p) => p.role == 'speaker').toList();
    final audience = allParticipants.where((p) => p.role == 'audience').toList();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Container(
              padding: const EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: deepPurple.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(6),
              ),
              child: const Icon(
                Icons.people,
                color: deepPurple,
                size: 18,
              ),
            ),
            const SizedBox(width: 8),
            const Text(
              'User Management',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w600,
                color: darkGray,
              ),
            ),
            const Spacer(),
            Text(
              '${allParticipants.length} total',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
        const SizedBox(height: 12),
        
        if (speakers.isNotEmpty) ...[
          Text(
            'Speakers (${speakers.length})',
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: darkGray,
            ),
          ),
          const SizedBox(height: 8),
          ...speakers.map((participant) => _buildUserManagementTile(participant)),
          const SizedBox(height: 16),
        ],
        
        if (audience.isNotEmpty) ...[
          Text(
            'Audience (${audience.length})',
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w600,
              color: darkGray,
            ),
          ),
          const SizedBox(height: 8),
          ...audience.map((participant) => _buildUserManagementTile(participant)),
        ],
      ],
    );
  }

  Widget _buildUserManagementTile(participant) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.grey[50],
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey[200]!),
      ),
      child: Row(
        children: [
          UserAvatar(
            avatarUrl: participant.avatarUrl,
            initials: participant.displayName.isNotEmpty ? participant.displayName[0].toUpperCase() : '?',
            radius: 16,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  participant.displayName,
                  style: const TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                    color: darkGray,
                  ),
                ),
                Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: participant.role == 'speaker' 
                            ? accentPurple.withValues(alpha: 0.1)
                            : Colors.grey.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        participant.role.toUpperCase(),
                        style: TextStyle(
                          fontSize: 10,
                          fontWeight: FontWeight.w600,
                          color: participant.role == 'speaker' ? accentPurple : Colors.grey[600],
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    if (participant.isSpeaking)
                      Container(
                        width: 6,
                        height: 6,
                        decoration: const BoxDecoration(
                          color: Colors.green,
                          shape: BoxShape.circle,
                        ),
                      ),
                  ],
                ),
              ],
            ),
          ),
          PopupMenuButton<String>(
            onSelected: (value) => _handleUserAction(participant.id, value),
            itemBuilder: (context) => [
              if (participant.role == 'audience')
                const PopupMenuItem(
                  value: 'promote',
                  child: Row(
                    children: [
                      Icon(Icons.arrow_upward, size: 16),
                      SizedBox(width: 8),
                      Text('Promote to Speaker'),
                    ],
                  ),
                ),
              if (participant.role == 'speaker')
                const PopupMenuItem(
                  value: 'demote',
                  child: Row(
                    children: [
                      Icon(Icons.arrow_downward, size: 16),
                      SizedBox(width: 8),
                      Text('Move to Audience'),
                    ],
                  ),
                ),
              const PopupMenuItem(
                value: 'mute',
                child: Row(
                  children: [
                    Icon(Icons.volume_off, size: 16),
                    SizedBox(width: 8),
                    Text('Mute'),
                  ],
                ),
              ),
            ],
            child: const Icon(Icons.more_vert, size: 16, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  Widget _buildFeatureChip(String label, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w600,
          color: color,
        ),
      ),
    );
  }

  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    
    if (difference.inMinutes < 1) {
      return 'Just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }


  Future<void> _handleUserAction(String userId, String action) async {
    try {
      switch (action) {
        case 'promote':
          await _participantService.updateRole(userId, 'speaker');
          break;
        case 'demote':
          await _participantService.updateRole(userId, 'audience');
          break;
        case 'mute':
          await _participantService.updateMuted(userId, true);
          break;
      }
      AppLogger().info('Performed action $action on participant $userId');
    } catch (e) {
      AppLogger().error('Failed to perform action $action: $e');
    }
  }

  Future<void> _muteAllParticipants() async {
    try {
      final participants = _participantService.all;
      for (final participant in participants) {
        if (participant.role != 'moderator' && !participant.isMuted) {
          await _participantService.updateMuted(participant.id, true);
        }
      }
      AppLogger().info('Muted all participants');
    } catch (e) {
      AppLogger().error('Failed to mute all participants: $e');
    }
  }

  // Close room function (moderator only - closes for all participants)
  Future<void> _closeRoom() async {
    try {
      // Show confirmation dialog first
      final shouldClose = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Row(
            children: [
              Icon(Icons.warning, color: scarletRed),
              SizedBox(width: 8),
              Text('Close Room'),
            ],
          ),
          content: const Text(
            'Are you sure you want to close this room?\n\n'
            '‚Ä¢ All participants will be removed\n'
            '‚Ä¢ The room will be permanently closed\n'
            '‚Ä¢ This action cannot be undone',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: ElevatedButton.styleFrom(
                backgroundColor: scarletRed,
                foregroundColor: Colors.white,
              ),
              child: const Text('Close Room'),
            ),
          ],
        ),
      );
      
      if (shouldClose == true && mounted) {
        // Show loading indicator
        showDialog(
          context: context,
          barrierDismissible: false,
          builder: (context) => const Center(
            child: CircularProgressIndicator(),
          ),
        );
        
        try {
          // Use OpenDiscussionService to close the room properly
          await _openDiscussionService.closeRoom(
            roomId: widget.roomName,
            moderatorId: _currentUserId ?? '',
            reason: 'moderator_closed',
          );
          
          AppLogger().info('‚úÖ Room closed successfully by moderator');
          
          // The room closure subscription will handle navigation for all users
          // But moderator should also leave immediately
          if (mounted) {
            Navigator.of(context).pop(); // Close loading dialog
            await _leaveRoom(); // Leave and navigate back
          }
          
        } catch (e) {
          AppLogger().error('‚ùå Failed to close room: $e');
          
          if (mounted) {
            Navigator.of(context).pop(); // Close loading dialog
            
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error closing room: ${e.toString()}'),
                backgroundColor: scarletRed,
              ),
            );
          }
        }
      }
    } catch (e) {
      AppLogger().error('‚ùå Error in close room dialog: $e');
    }
  }

  // =====================================================
  // GIFT SYSTEM IMPLEMENTATION
  // =====================================================

  void _showGiftModal() {
    debugPrint('üéÅ DEBUG: Gift modal button pressed');
    debugPrint('üéÅ DEBUG: Current user ID: $_currentUserId');
    debugPrint('üéÅ DEBUG: Current coin balance: $_currentUserCoinBalance');
    
    // Get available recipients (speakers + moderators, excluding self)
    final recipients = <Map<String, dynamic>>[];
    
    // Add moderator (from participant service)
    final moderator = _participantService.getModeratorParticipant();
    if (moderator != null && moderator.id != _currentUserId) {
      recipients.add({
        'userId': moderator.id,
        'role': 'moderator',
        'displayName': moderator.displayName,
        'avatarUrl': moderator.avatarUrl,
      });
      debugPrint('üéÅ DEBUG: Added moderator as recipient');
    }
    
    // Add speakers (excluding current user if they're a speaker)
    final speakers = _getSpeakers();
    for (final speaker in speakers) {
      if (speaker.id != _currentUserId) {
        recipients.add({
          'userId': speaker.id,
          'role': 'speaker',
          'displayName': speaker.displayName,
          'avatarUrl': speaker.avatarUrl,
        });
        debugPrint('üéÅ DEBUG: Added speaker as recipient: ${speaker.id}');
      }
    }
    
    debugPrint('üéÅ DEBUG: Total recipients: ${recipients.length}');
    
    if (recipients.isEmpty) {
      debugPrint('üéÅ DEBUG: No recipients available');
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No speakers or moderators to send gifts to'),
          backgroundColor: Colors.orange,
        ),
      );
      return;
    }

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => Container(
        height: MediaQuery.of(context).size.height * 0.85,
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
          ),
        ),
        child: Column(
          children: [
            // Handle bar
            Container(
              margin: const EdgeInsets.only(top: 10),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.grey.shade300,
                borderRadius: const BorderRadius.all(Radius.circular(2)),
              ),
            ),
            
            // Header
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                border: Border(
                  bottom: BorderSide(
                    color: Colors.grey.shade200,
                    width: 1,
                  ),
                ),
              ),
              child: Row(
                children: [
                  const Icon(
                    Icons.card_giftcard,
                    color: Colors.amber,
                    size: 24,
                  ),
                  const SizedBox(width: 10),
                  const Text(
                    'Send Gift',
                    style: TextStyle(
                      color: deepPurple,
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Spacer(),
                  // Coin balance display with refresh
                  GestureDetector(
                    onTap: () async {
                      debugPrint('üéÅ DEBUG: Manual coin refresh tapped');
                      await _loadFirebaseCoinBalance();
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.amber.withValues(alpha: 0.1),
                        borderRadius: const BorderRadius.all(Radius.circular(20)),
                        border: Border.all(color: Colors.amber.withValues(alpha: 0.3)),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.monetization_on, color: Colors.amber, size: 16),
                          const SizedBox(width: 4),
                          Text(
                            '$_currentUserCoinBalance',
                            style: TextStyle(
                              color: Colors.amber.shade700,
                              fontWeight: FontWeight.bold,
                              fontSize: 14,
                            ),
                          ),
                          const SizedBox(width: 4),
                          const Icon(Icons.refresh, color: Colors.amber, size: 12),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(width: 10),
                  IconButton(
                    onPressed: () => Navigator.pop(context),
                    icon: Icon(
                      Icons.close,
                      color: Colors.grey.shade600,
                    ),
                  ),
                ],
              ),
            ),
            
            // Content
            Expanded(
              child: DefaultTabController(
                length: 2,
                child: Column(
                  children: [
                    // Tab bar
                    const TabBar(
                      labelColor: deepPurple,
                      unselectedLabelColor: Colors.grey,
                      indicatorColor: scarletRed,
                      tabs: [
                        Tab(text: 'Select Gift'),
                        Tab(text: 'Recipients'),
                      ],
                    ),
                    
                    // Tab views
                    Expanded(
                      child: TabBarView(
                        children: [
                          _buildGiftSelectionTab(),
                          _buildRecipientSelectionTab(recipients),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGiftSelectionTab() {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Gift categories
          ...GiftCategory.values.map((category) => _buildGiftCategorySection(category)),
        ],
      ),
    );
  }

  Widget _buildGiftCategorySection(GiftCategory category) {
    final categoryGifts = GiftConstants.getGiftsByCategory(category);
    if (categoryGifts.isEmpty) return Container();

    String categoryTitle = '';
    IconData categoryIcon = Icons.card_giftcard;
    Color categoryColor = Colors.grey;

    switch (category) {
      case GiftCategory.intellectual:
        categoryTitle = 'Intellectual Achievement';
        categoryIcon = Icons.psychology;
        categoryColor = Colors.blue;
        break;
      case GiftCategory.supportive:
        categoryTitle = 'Supportive & Encouraging';
        categoryIcon = Icons.favorite;
        categoryColor = Colors.pink;
        break;
      case GiftCategory.fun:
        categoryTitle = 'Fun & Personality';
        categoryIcon = Icons.celebration;
        categoryColor = Colors.orange;
        break;
      case GiftCategory.recognition:
        categoryTitle = 'Recognition & Status';
        categoryIcon = Icons.star;
        categoryColor = Colors.amber;
        break;
      case GiftCategory.interactive:
        categoryTitle = 'Interactive & Engaging';
        categoryIcon = Icons.play_circle;
        categoryColor = Colors.green;
        break;
      case GiftCategory.premium:
        categoryTitle = 'Premium Collection';
        categoryIcon = Icons.diamond;
        categoryColor = Colors.purple;
        break;
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Category header
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 12),
          child: Row(
            children: [
              Icon(categoryIcon, color: categoryColor, size: 20),
              const SizedBox(width: 8),
              Text(
                categoryTitle,
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                  color: categoryColor,
                ),
              ),
            ],
          ),
        ),
        
        // Gift grid
        GridView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 2,
            crossAxisSpacing: 10,
            mainAxisSpacing: 10,
            childAspectRatio: 1.2,
          ),
          itemCount: categoryGifts.length,
          itemBuilder: (context, index) {
            final gift = categoryGifts[index];
            return _buildGiftCard(gift);
          },
        ),
        
        const SizedBox(height: 20),
      ],
    );
  }

  Widget _buildGiftCard(Gift gift) {
    final canAfford = _currentUserCoinBalance >= gift.cost;
    final isSelected = _selectedGift?.id == gift.id;
    
    return GestureDetector(
      onTap: canAfford ? () => _selectGift(gift) : null,
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isSelected 
            ? scarletRed.withValues(alpha: 0.1)
            : (canAfford ? Colors.white : Colors.grey.shade100),
          borderRadius: const BorderRadius.all(Radius.circular(12)),
          border: Border.all(
            color: isSelected 
              ? scarletRed 
              : (canAfford ? _getTierColor(gift.tier) : Colors.grey.shade300),
            width: isSelected ? 2.5 : 1.5,
          ),
          boxShadow: canAfford ? [
            BoxShadow(
              color: _getTierColor(gift.tier).withValues(alpha: 0.1),
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ] : null,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Gift emoji and effects
            Row(
              children: [
                Text(
                  gift.emoji,
                  style: TextStyle(
                    fontSize: 24,
                    color: canAfford ? null : Colors.grey,
                  ),
                ),
                const Spacer(),
                if (gift.hasVisualEffect)
                  const Icon(Icons.auto_awesome, size: 12, color: Colors.amber),
                if (gift.hasProfileBadge)
                  const Icon(Icons.shield, size: 12, color: Colors.blue),
              ],
            ),
            
            const SizedBox(height: 4),
            
            // Gift name
            Text(
              gift.name,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: canAfford ? deepPurple : Colors.grey,
              ),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
            
            const SizedBox(height: 2),
            
            // Gift description
            Text(
              gift.description,
              style: TextStyle(
                fontSize: 10,
                color: canAfford ? Colors.grey.shade600 : Colors.grey.shade400,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            
            const Spacer(),
            
            // Cost
            Row(
              children: [
                Icon(
                  Icons.monetization_on,
                  size: 12,
                  color: canAfford ? Colors.amber : Colors.grey,
                ),
                const SizedBox(width: 2),
                Text(
                  '${gift.cost}',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                    color: canAfford ? Colors.amber.shade700 : Colors.grey,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRecipientSelectionTab(List<Map<String, dynamic>> recipients) {
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: recipients.length,
      itemBuilder: (context, index) {
        final recipient = recipients[index];
        final userProfile = _userProfileCache[recipient['userId']];
        final isSelected = _selectedRecipient?['userId'] == recipient['userId'];
        
        return Container(
          margin: const EdgeInsets.only(bottom: 12),
          decoration: BoxDecoration(
            borderRadius: const BorderRadius.all(Radius.circular(12)),
            border: isSelected 
              ? Border.all(color: scarletRed, width: 2)
              : null,
            color: isSelected 
              ? scarletRed.withValues(alpha: 0.1)
              : null,
          ),
          child: ListTile(
            leading: CircleAvatar(
              backgroundColor: accentPurple.withValues(alpha: 0.2),
              backgroundImage: userProfile?.avatar != null 
                ? NetworkImage(userProfile!.avatar!) 
                : null,
              child: userProfile?.avatar == null 
                ? Text(
                    userProfile?.name?.isNotEmpty == true ? userProfile!.name![0].toUpperCase() : 'U',
                    style: const TextStyle(
                      color: deepPurple,
                      fontWeight: FontWeight.bold,
                    ),
                  )
                : null,
            ),
            title: Text(
              userProfile?.displayName ?? recipient['displayName'] ?? 'User',
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
            subtitle: Text(
              recipient['role'] == 'moderator' ? 'Moderator' : 'Speaker',
              style: TextStyle(
                color: recipient['role'] == 'moderator' ? scarletRed : Colors.green,
                fontSize: 12,
              ),
            ),
            trailing: Icon(
              recipient['role'] == 'moderator' ? Icons.admin_panel_settings : Icons.mic,
              color: recipient['role'] == 'moderator' ? scarletRed : Colors.green,
            ),
            onTap: () => _selectRecipient(recipient),
          ),
        );
      },
    );
  }

  Color _getTierColor(GiftTier tier) {
    switch (tier) {
      case GiftTier.basic:
        return Colors.grey;
      case GiftTier.standard:
        return Colors.blue;
      case GiftTier.premium:
        return Colors.purple;
      case GiftTier.legendary:
        return Colors.amber;
    }
  }

  void _selectGift(Gift gift) {
    debugPrint('üéÅ DEBUG: Attempting to select gift: ${gift.name}');
    debugPrint('üéÅ DEBUG: Gift cost: ${gift.cost}');
    debugPrint('üéÅ DEBUG: User balance: $_currentUserCoinBalance');
    debugPrint('üéÅ DEBUG: Can afford: ${_currentUserCoinBalance >= gift.cost}');
    
    setState(() {
      _selectedGift = gift;
    });
    
    debugPrint('üéÅ DEBUG: Gift selected successfully: ${gift.name}');
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Selected ${gift.emoji} ${gift.name}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 1),
      ),
    );

    // If both gift and recipient are selected, show confirmation
    if (_selectedRecipient != null) {
      _showGiftConfirmation();
    }
  }

  void _selectRecipient(Map<String, dynamic> recipient) {
    setState(() {
      _selectedRecipient = recipient;
    });
    
    final userProfile = _userProfileCache[recipient['userId']];
    debugPrint('Selected recipient: ${userProfile?.displayName ?? recipient['displayName']}');
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Selected recipient: ${userProfile?.displayName ?? recipient['displayName']}'),
        backgroundColor: Colors.green,
        duration: const Duration(seconds: 1),
      ),
    );

    // If both gift and recipient are selected, show confirmation
    if (_selectedGift != null) {
      _showGiftConfirmation();
    }
  }

  void _showGiftConfirmation() {
    if (_selectedGift == null || _selectedRecipient == null) return;

    final gift = _selectedGift!;
    final recipient = _selectedRecipient!;
    final recipientProfile = _userProfileCache[recipient['userId']];

    Navigator.pop(context); // Close gift modal

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Send Gift?'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Send ${gift.emoji} ${gift.name} to ${recipientProfile?.displayName ?? recipient['displayName'] ?? 'Unknown User'}?'),
            const SizedBox(height: 8),
            Text('Cost: ${gift.cost} coins'),
            const SizedBox(height: 8),
            Text('Your balance: $_currentUserCoinBalance coins'),
            if (_currentUserCoinBalance < gift.cost)
              const Padding(
                padding: EdgeInsets.only(top: 8),
                child: Text(
                  'Insufficient coins!',
                  style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
                ),
              ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: _currentUserCoinBalance >= gift.cost 
              ? () => _sendGift(gift, recipient)
              : null,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.amber,
              foregroundColor: Colors.white,
            ),
            child: const Text('Send Gift'),
          ),
        ],
      ),
    );
  }

  Future<void> _sendGift(Gift gift, Map<String, dynamic> recipient) async {
    if (_currentUserId == null) return;

    try {
      Navigator.pop(context); // Close confirmation dialog

      // Show loading
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
                ),
                SizedBox(width: 10),
                Text('Sending gift...'),
              ],
            ),
            backgroundColor: Colors.blue,
            duration: Duration(seconds: 2),
          ),
        );
      }

      // Send gift via Firebase
      await _firebaseGiftService.sendGift(
        giftId: gift.id,
        senderId: _currentUserId!,
        recipientId: recipient['userId'],
        roomId: widget.roomName,
        cost: gift.cost,
      );

      // Refresh Firebase coin balance
      await _loadFirebaseCoinBalance();

      // Show success notification
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('üéÅ Gift sent! ${gift.emoji} ${gift.name}'),
            backgroundColor: Colors.green,
          ),
        );
      }

      // Reset selections
      setState(() {
        _selectedGift = null;
        _selectedRecipient = null;
      });

    } catch (e) {
      debugPrint('Error sending gift: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send gift: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // User Profile Bottom Sheet Implementation
  void _showUserProfile(UserProfile userProfile, String? userRole) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => UserProfileBottomSheet(
        user: userProfile,
        onFollow: () {
          // TODO: Implement follow functionality
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Following ${userProfile.name}'),
                backgroundColor: const Color(0xFF10B981),
              ),
            );
          }
        },
        onChallenge: () {
          // Challenge functionality is now handled directly by UserProfileBottomSheet
          debugPrint('Challenge functionality delegated to UserProfileBottomSheet');
        },
        onEmail: () {
          if (mounted && _currentUserProfile != null) {
            final currentUser = _currentUserProfile!;
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => EmailComposeScreen(
                  currentUserId: currentUser.id,
                  currentUsername: currentUser.name,
                  recipient: userProfile,
                ),
              ),
            );
          }
        },
      ),
    );
  }
}
