import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import 'package:socket_io_client/socket_io_client.dart' as io;

class SimpleMediaSoupService extends ChangeNotifier {
  static final SimpleMediaSoupService _instance = SimpleMediaSoupService._internal();
  factory SimpleMediaSoupService() => _instance;
  SimpleMediaSoupService._internal();

  // Socket.IO connection
  io.Socket? _socket;
  
  // SFU Mode flag
  bool _sfuMode = false;
  
  // WebRTC - P2P mode (existing)
  final Map<String, RTCPeerConnection> _peerConnections = {};
  final Map<String, MediaStream> _remoteStreams = {};
  MediaStream? _localStream;
  final Map<String, RTCVideoRenderer> _videoRenderers = {};
  
  // SFU Mode specific
  RTCPeerConnection? _sendTransport;
  RTCPeerConnection? _recvTransport;
  String? _sendTransportId;
  String? _recvTransportId;
  final Map<String, RTCRtpSender> _producers = {}; // producerId -> sender
  final Map<String, RTCRtpReceiver> _consumers = {}; // consumerId -> receiver
  Map<String, dynamic>? _routerRtpCapabilities;
  Map<String, dynamic>? _deviceRtpCapabilities;
  
  // State
  bool _isConnected = false;
  bool _isMuted = false;
  bool _isVideoEnabled = false;
  bool _isDisposed = false;
  String? _currentRoom;
  String? _userId;
  String? _userRole; // 'moderator', 'speaker', 'audience'
  String? _myPeerId;
  
  // Callbacks
  Function(MediaStream)? onLocalStream;
  Function(String peerId, MediaStream stream, String? userId, String? role)? onRemoteStream;
  Function(String peerId, String? userId, String? role)? onPeerJoined;
  Function(String peerId)? onPeerLeft;
  Function(String)? onError;
  Function()? onConnected;
  Function()? onDisconnected;
  
  // Getters
  bool get isConnected => _isConnected;
  bool get isMuted => _isMuted;
  bool get isLocalVideoEnabled => _isVideoEnabled;
  String? get userRole => _userRole;
  MediaStream? get localStream => _localStream;
  Map<String, MediaStream> get remoteStreams => _remoteStreams;
  Map<String, RTCVideoRenderer> get videoRenderers => _videoRenderers;
  
  // P2P tracking
  final Set<String> _connectedPeers = {};
  final Map<String, Map<String, String?>> _peerMetadata = {};
  String? _mySocketId;

  Future<void> connect(String serverUrl, String room, String userId, 
      {bool audioOnly = true, String role = 'audience', bool sfuMode = false}) async {
    try {
      _sfuMode = sfuMode;
      
      // Force SFU mode for large rooms or specific roles
      if (role == 'moderator' || role == 'speaker') {
        _sfuMode = true;
        debugPrint('üéØ Forcing SFU mode for ${role}');
      }
      
      debugPrint('üîå Connecting in ${_sfuMode ? "SFU" : "P2P"} mode');
      
      // Check if already connected
      if (_isConnected && _socket != null && _socket!.connected && _currentRoom == room) {
        debugPrint('‚ö†Ô∏è Already connected to room: $room');
        return;
      }
      
      // Clean up if switching rooms
      if (_socket != null || _currentRoom != room) {
        await _forceDisconnect();
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      _currentRoom = room;
      _userId = userId;
      _userRole = role;
      
      // Connect to server
      const serverPort = '3001';
      const protocol = 'http';
      final namespace = _sfuMode ? '' : '/signaling'; // SFU uses default namespace
      final serverUri = '$protocol://$serverUrl:$serverPort$namespace';
      
      debugPrint('üîå Connecting to: $serverUri');
      
      _socket = io.io(serverUri, <String, dynamic>{
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'timeout': 20000,
        'forceNew': true,
        'upgrade': true,
      });
      
      if (_sfuMode) {
        _setupSFUSocketListeners();
      } else {
        _setupP2PSocketListeners();
      }
      
      _socket!.connect();
      
      // Wait for connection
      await _waitForConnection();
      
      if (_sfuMode) {
        await _connectSFU(room, userId, role, audioOnly);
      } else {
        await _connectP2P(room, userId, role, audioOnly);
      }
      
      _isConnected = true;
      onConnected?.call();
      notifyListeners();
      
    } catch (e) {
      debugPrint('‚ùå Connection error: $e');
      onError?.call(e.toString());
      rethrow;
    }
  }

  // ============= SFU MODE IMPLEMENTATION =============
  
  Future<void> _connectSFU(String room, String userId, String role, bool audioOnly) async {
    debugPrint('üé¨ Starting SFU connection flow');
    
    // 1. Join room
    final joinCompleter = Completer<void>();
    _socket!.once('room-joined', (data) {
      _myPeerId = data['peerId'];
      debugPrint('‚úÖ Joined room as peer: $_myPeerId');
      joinCompleter.complete();
    });
    
    _socket!.emit('join-room', {
      'roomId': room,
      'userId': userId,
      'role': role,
    });
    
    await joinCompleter.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('Failed to join room'),
    );
    
    // 2. Get router RTP capabilities
    final rtpCapabilities = await _rpcRequest('getRouterRtpCapabilities', {'roomId': room});
    _routerRtpCapabilities = rtpCapabilities['rtpCapabilities'];
    debugPrint('üì° Got router RTP capabilities');
    
    // 3. Initialize device capabilities (simplified for flutter_webrtc)
    _deviceRtpCapabilities = _routerRtpCapabilities; // Simplified - in real mediasoup-client this would be device.load()
    
    // 4. Create transports
    if (role == 'moderator' || role == 'speaker') {
      await _createSendTransport(room);
    }
    await _createRecvTransport(room);
    
    // 5. Initialize media and produce if needed
    if ((role == 'moderator' || role == 'speaker') && !audioOnly) {
      await _initializeMedia(audioOnly: audioOnly);
      await _produceTracks();
    } else if (role == 'moderator' || role == 'speaker') {
      // Audio only for speakers
      await _initializeMedia(audioOnly: true);
      await _produceTracks();
    }
    
    // 6. Consume existing producers
    await _consumeExistingProducers(room);
  }
  
  Future<void> _createSendTransport(String roomId) async {
    debugPrint('üöõ Creating send transport');
    
    final response = await _rpcRequest('createWebRtcTransport', {
      'roomId': roomId,
      'direction': 'send',
    });
    
    _sendTransportId = response['id'];
    
    // Create RTCPeerConnection for send transport
    _sendTransport = await createPeerConnection({
      'iceServers': [
        {'urls': 'stun:stun.l.google.com:19302'},
        {'urls': 'stun:stun1.l.google.com:19302'},
      ],
    });
    
    // Handle ICE gathering
    _sendTransport!.onIceCandidate = (candidate) {
      // In MediaSoup, we don't send individual ICE candidates
      // They are included in the transport parameters
    };
    
    // Set remote ICE parameters and candidates from server
    // This is a simplified approach - real mediasoup-client handles this differently
    await _connectTransport(_sendTransportId!, response, _sendTransport!);
    
    debugPrint('‚úÖ Send transport created: $_sendTransportId');
  }
  
  Future<void> _createRecvTransport(String roomId) async {
    debugPrint('üöõ Creating receive transport');
    
    final response = await _rpcRequest('createWebRtcTransport', {
      'roomId': roomId,
      'direction': 'recv',
    });
    
    _recvTransportId = response['id'];
    
    // Create RTCPeerConnection for receive transport
    _recvTransport = await createPeerConnection({
      'iceServers': [
        {'urls': 'stun:stun.l.google.com:19302'},
        {'urls': 'stun:stun1.l.google.com:19302'},
      ],
    });
    
    // Handle incoming tracks
    _recvTransport!.onTrack = (event) {
      if (event.streams.isNotEmpty) {
        final stream = event.streams[0];
        final trackId = event.track.id;
        
        debugPrint('üé¨ Received track: ${event.track.kind} (${trackId})');
        
        // Find which consumer this track belongs to
        String? peerId;
        String? userId;
        String? role;
        
        // Map track to peer metadata (stored during consume)
        _consumers.forEach((consumerId, receiver) {
          if (receiver.track?.id == trackId) {
            final metadata = _consumerMetadata[consumerId];
            if (metadata != null) {
              peerId = metadata['peerId'];
              userId = metadata['userId'];
              role = metadata['role'];
            }
          }
        });
        
        if (peerId != null) {
          _remoteStreams[peerId!] = stream;
          
          // Initialize video renderer if needed
          if (stream.getVideoTracks().isNotEmpty && !_videoRenderers.containsKey(peerId)) {
            final renderer = RTCVideoRenderer();
            renderer.initialize().then((_) {
              renderer.srcObject = stream;
              _videoRenderers[peerId!] = renderer;
              debugPrint('üé• Video renderer initialized for peer: $peerId');
            });
          }
          
          onRemoteStream?.call(peerId!, stream, userId, role);
        }
      }
    };
    
    await _connectTransport(_recvTransportId!, response, _recvTransport!);
    
    debugPrint('‚úÖ Receive transport created: $_recvTransportId');
  }
  
  Future<void> _connectTransport(String transportId, Map<String, dynamic> params, RTCPeerConnection pc) async {
    // Create offer/answer to establish DTLS
    if (_sendTransport == pc) {
      // For send transport, we create offer
      final offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      // Send DTLS parameters to server
      await _rpcRequest('connectWebRtcTransport', {
        'transportId': transportId,
        'dtlsParameters': {
          // Extract DTLS parameters from SDP
          'fingerprints': [/* parsed from SDP */],
          'role': 'client',
        },
      });
    } else {
      // For receive transport, we might need to handle this differently
      // This is simplified - real mediasoup-client has more complex handling
    }
  }
  
  Future<void> _produceTracks() async {
    if (_localStream == null || _sendTransport == null) return;
    
    debugPrint('üéôÔ∏è Producing tracks');
    
    // Produce audio
    final audioTracks = _localStream!.getAudioTracks();
    if (audioTracks.isNotEmpty) {
      final audioTrack = audioTracks.first;
      final audioSender = await _sendTransport!.addTrack(audioTrack, _localStream!);
      
      // Get RTP parameters (simplified - real implementation would use getParameters())
      final audioParams = await audioSender.getParameters();
      
      final response = await _rpcRequest('produce', {
        'roomId': _currentRoom,
        'transportId': _sendTransportId,
        'kind': 'audio',
        'rtpParameters': audioParams,
        'appData': {
          'userId': _userId,
          'role': _userRole,
        },
      });
      
      _producers[response['producerId']] = audioSender;
      debugPrint('‚úÖ Audio producer created: ${response['producerId']}');
    }
    
    // Produce video
    final videoTracks = _localStream!.getVideoTracks();
    if (videoTracks.isNotEmpty && _isVideoEnabled) {
      final videoTrack = videoTracks.first;
      final videoSender = await _sendTransport!.addTrack(videoTrack, _localStream!);
      
      final videoParams = await videoSender.getParameters();
      
      final response = await _rpcRequest('produce', {
        'roomId': _currentRoom,
        'transportId': _sendTransportId,
        'kind': 'video',
        'rtpParameters': videoParams,
        'appData': {
          'userId': _userId,
          'role': _userRole,
        },
      });
      
      _producers[response['producerId']] = videoSender;
      debugPrint('‚úÖ Video producer created: ${response['producerId']}');
    }
  }
  
  final Map<String, Map<String, String?>> _consumerMetadata = {}; // consumerId -> metadata
  
  Future<void> _consumeExistingProducers(String roomId) async {
    debugPrint('üéß Consuming existing producers');
    
    final response = await _rpcRequest('listProducers', {'roomId': roomId});
    final producers = response['producers'] as List;
    
    debugPrint('üìã Found ${producers.length} existing producers');
    
    for (final producer in producers) {
      final producerId = producer['producerId'];
      final peerId = producer['peerId'];
      
      // Don't consume own producers
      if (peerId == _myPeerId) continue;
      
      await _consumeProducer(
        producerId: producerId,
        peerId: peerId,
        userId: producer['userId'],
        role: producer['role'],
        kind: producer['kind'],
      );
    }
  }
  
  Future<void> _consumeProducer({
    required String producerId,
    required String peerId,
    required String userId,
    required String role,
    required String kind,
  }) async {
    debugPrint('üéß Consuming $kind from $userId ($role)');
    
    try {
      final response = await _rpcRequest('consume', {
        'roomId': _currentRoom,
        'transportId': _recvTransportId,
        'producerId': producerId,
        'rtpCapabilities': _deviceRtpCapabilities,
      });
      
      final consumerId = response['id'];
      final rtpParameters = response['rtpParameters'];
      
      // Store metadata for track mapping
      _consumerMetadata[consumerId] = {
        'peerId': peerId,
        'userId': userId,
        'role': role,
        'producerId': producerId,
      };
      
      // Add transceiver to receive this track
      final transceiver = await _recvTransport!.addTransceiver(
        kind: kind == 'audio' ? RTCRtpMediaType.RTCRtpMediaTypeAudio : RTCRtpMediaType.RTCRtpMediaTypeVideo,
        init: RTCRtpTransceiverInit(
          direction: TransceiverDirection.RecvOnly,
          streams: [
            // Create or get stream for this peer
            _remoteStreams[peerId] ?? MediaStream(peerId),
          ],
        ),
      );
      
      _consumers[consumerId] = transceiver.receiver;
      
      // Resume consumer
      await _rpcRequest('resumeConsumer', {'consumerId': consumerId});
      
      debugPrint('‚úÖ Consumer created and resumed: $consumerId for $kind from $userId');
      
    } catch (e) {
      debugPrint('‚ùå Error consuming producer: $e');
    }
  }
  
  void _setupSFUSocketListeners() {
    _socket!.on('connect', (_) {
      debugPrint('‚úÖ SFU Socket connected! ID: ${_socket!.id}');
    });
    
    _socket!.on('disconnect', (_) {
      debugPrint('üîå SFU Socket disconnected');
      _handleDisconnection();
    });
    
    // New producer in room
    _socket!.on('newProducer', (data) async {
      final producerId = data['producerId'];
      final peerId = data['peerId'];
      final userId = data['userId'];
      final role = data['role'];
      final kind = data['kind'];
      
      debugPrint('üÜï New producer: $kind from $userId ($role)');
      
      // Don't consume own producers
      if (peerId == _myPeerId) return;
      
      await _consumeProducer(
        producerId: producerId,
        peerId: peerId,
        userId: userId,
        role: role,
        kind: kind,
      );
    });
    
    // Producer closed
    _socket!.on('producerClosed', (data) {
      final producerId = data['producerId'];
      final peerId = data['peerId'];
      
      debugPrint('üõë Producer closed: $producerId from peer $peerId');
      
      // Find and remove consumer for this producer
      String? consumerIdToRemove;
      _consumerMetadata.forEach((consumerId, metadata) {
        if (metadata['producerId'] == producerId) {
          consumerIdToRemove = consumerId;
        }
      });
      
      if (consumerIdToRemove != null) {
        _consumers.remove(consumerIdToRemove);
        _consumerMetadata.remove(consumerIdToRemove);
      }
    });
    
    // Peer left
    _socket!.on('peerLeft', (data) {
      final peerId = data['peerId'];
      debugPrint('üëã Peer left: $peerId');
      
      _cleanupPeer(peerId);
      onPeerLeft?.call(peerId);
    });
    
    // Peer joined (for presence awareness)
    _socket!.on('peer-joined', (data) {
      final peerId = data['peerId'];
      final userId = data['userId'];
      final role = data['role'];
      
      debugPrint('üë§ Peer joined: $userId ($role) as $peerId');
      onPeerJoined?.call(peerId, userId, role);
    });
    
    // Error handling
    _socket!.on('error', (error) {
      debugPrint('‚ùå SFU Socket error: $error');
      onError?.call(error.toString());
    });
  }
  
  Future<Map<String, dynamic>> _rpcRequest(String method, Map<String, dynamic> params) async {
    final completer = Completer<Map<String, dynamic>>();
    
    _socket!.emit('request', {
      'method': method,
      'params': params,
    }, (response) {
      if (response['error'] != null) {
        completer.completeError(Exception(response['error']));
      } else {
        completer.complete(response);
      }
    });
    
    return completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('RPC request timeout: $method'),
    );
  }
  
  void _cleanupPeer(String peerId) {
    // Remove streams and renderers
    _remoteStreams.remove(peerId)?.dispose();
    _videoRenderers.remove(peerId)?.dispose();
    
    // Remove consumer metadata for this peer
    _consumerMetadata.removeWhere((_, metadata) => metadata['peerId'] == peerId);
    
    notifyListeners();
  }

  // ============= P2P MODE IMPLEMENTATION (existing) =============
  
  Future<void> _connectP2P(String room, String userId, String role, bool audioOnly) async {
    // Existing P2P implementation
    final joinData = {
      'roomId': room,
      'userId': userId,
      'role': role,
    };
    _socket!.emit('join-room', joinData);
    
    // Wait for room joined confirmation
    final completer = Completer<void>();
    _socket!.once('room-joined', (data) {
      debugPrint('‚úÖ Successfully joined room: $data');
      completer.complete();
    });
    
    await completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('Failed to join room'),
    );
    
    // Initialize media if not audience
    if (role != 'audience' || !audioOnly) {
      await _initializeMedia(audioOnly: audioOnly);
    }
  }
  
  void _setupP2PSocketListeners() {
    // Existing P2P socket listeners (keep as is)
    _socket!.on('connect', (_) {
      _mySocketId = _socket!.id;
      debugPrint('‚úÖ P2P Socket connected! ID: $_mySocketId');
    });
    
    // ... rest of P2P implementation remains the same
  }
  
  // ============= SHARED METHODS =============
  
  Future<void> _initializeMedia({required bool audioOnly}) async {
    try {
      // Skip media for audience in both modes
      if (_userRole == 'audience' && (_sfuMode || audioOnly)) {
        debugPrint('üé≠ Audience member - skipping local media setup');
        return;
      }
      
      final Map<String, dynamic> mediaConstraints = {
        'audio': {
          'echoCancellation': true,
          'noiseSuppression': true,
          'autoGainControl': true,
        },
        'video': audioOnly ? false : {
          'width': {'ideal': 640},
          'height': {'ideal': 480},
          'frameRate': {'ideal': 30},
          'facingMode': 'user',
        },
      };
      
      _localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      onLocalStream?.call(_localStream!);
      
      // Set initial video state
      if (!audioOnly && _localStream!.getVideoTracks().isNotEmpty) {
        _isVideoEnabled = true;
        debugPrint('üé• Local video initialized with ${_localStream!.getVideoTracks().length} tracks');
      }
      
    } catch (e) {
      debugPrint('‚ùå Media initialization error: $e');
      throw Exception('Failed to access media devices: $e');
    }
  }
  
  Future<void> toggleMute() async {
    if (_localStream != null) {
      _isMuted = !_isMuted;
      _localStream!.getAudioTracks().forEach((track) {
        track.enabled = !_isMuted;
      });
      
      // In SFU mode, we might need to notify server
      if (_sfuMode) {
        // Could implement producer.pause() / producer.resume() here
      }
      
      notifyListeners();
    }
  }
  
  Future<void> toggleLocalVideo() async {
    if (_localStream != null) {
      _isVideoEnabled = !_isVideoEnabled;
      _localStream!.getVideoTracks().forEach((track) {
        track.enabled = _isVideoEnabled;
      });
      
      // In SFU mode, handle video producer
      if (_sfuMode && _sendTransport != null) {
        if (_isVideoEnabled) {
          // Re-produce video if it was stopped
          if (_localStream!.getVideoTracks().isNotEmpty) {
            await _produceTracks(); // This will only produce video if not already producing
          }
        } else {
          // Could close video producer here
          // Find video producer and close it
          for (final entry in _producers.entries) {
            if (entry.value.track?.kind == 'video') {
              await _rpcRequest('closeProducer', {'producerId': entry.key});
              _producers.remove(entry.key);
              break;
            }
          }
        }
      }
      
      debugPrint('üé• Local video ${_isVideoEnabled ? 'enabled' : 'disabled'}');
      notifyListeners();
    }
  }
  
  Future<void> _waitForConnection() async {
    final completer = Completer<void>();
    
    if (_socket!.connected) {
      completer.complete();
    } else {
      _socket!.once('connect', (_) => completer.complete());
    }
    
    await completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('Socket connection timeout'),
    );
  }
  
  void _handleDisconnection() {
    _isConnected = false;
    
    if (_sfuMode) {
      // Clean up SFU resources
      _sendTransport?.close();
      _recvTransport?.close();
      _sendTransport = null;
      _recvTransport = null;
      _producers.clear();
      _consumers.clear();
      _consumerMetadata.clear();
    } else {
      // Clean up P2P resources
      for (final peerId in _peerConnections.keys.toList()) {
        _cleanupPeerConnection(peerId);
      }
    }
    
    // Clean up common resources
    _localStream?.dispose();
    _localStream = null;
    _remoteStreams.clear();
    _videoRenderers.values.forEach((renderer) => renderer.dispose());
    _videoRenderers.clear();
    
    onDisconnected?.call();
    notifyListeners();
  }
  
  Future<void> _forceDisconnect() async {
    if (_isDisposed) return;
    
    // Clean up socket
    if (_socket != null) {
      _socket!.disconnect();
      _socket!.dispose();
      _socket = null;
    }
    
    // Clean up all connections and streams
    _handleDisconnection();
    
    // Reset state
    _currentRoom = null;
    _userId = null;
    _userRole = null;
    _mySocketId = null;
    _myPeerId = null;
    _isConnected = false;
    _isMuted = false;
    _isVideoEnabled = false;
    _sfuMode = false;
  }
  
  Future<void> disconnect() async {
    if (_isDisposed) return;
    await _forceDisconnect();
    notifyListeners();
  }
  
  @override
  void dispose() {
    _isDisposed = true;
    disconnect();
    super.dispose();
  }
  
  // P2P specific methods (keep existing implementation)
  void _cleanupPeerConnection(String peerId) {
    // Existing P2P cleanup code...
  }
}