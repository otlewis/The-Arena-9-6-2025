import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_webrtc/flutter_webrtc.dart';
import 'package:socket_io_client/socket_io_client.dart' as io;

class SimpleMediaSoupService extends ChangeNotifier {
  static final SimpleMediaSoupService _instance = SimpleMediaSoupService._internal();
  factory SimpleMediaSoupService() => _instance;
  SimpleMediaSoupService._internal();

  // Socket.IO connection
  io.Socket? _socket;
  
  // WebRTC - Multiple peer connections for multi-user support
  final Map<String, RTCPeerConnection> _peerConnections = {};
  final Map<String, MediaStream> _remoteStreams = {};
  MediaStream? _localStream;
  final Map<String, RTCVideoRenderer> _videoRenderers = {};
  
  // State
  bool _isConnected = false;
  bool _isMuted = false;
  bool _isVideoEnabled = false;
  bool _isDisposed = false;
  Map<String, dynamic>? _rtpCapabilities;
  String? _currentRoom; // Track current room
  String? _userId;
  String? _userRole; // 'moderator', 'speaker', 'audience'
  
  // Audio-only mode - video state tracking removed
  
  // Callbacks
  Function(MediaStream)? onLocalStream;
  Function(String peerId, MediaStream stream, String? userId, String? role)? onRemoteStream;
  Function(String peerId, String? userId, String? role)? onPeerJoined;
  Function(String peerId)? onPeerLeft;
  Function(String)? onError;
  Function()? onConnected;
  Function()? onDisconnected;
  
  // Audio-only mode - video callbacks removed
  
  // Getters
  bool get isConnected => _isConnected;
  bool get isMuted => _isMuted;
  bool get isLocalVideoEnabled => _isVideoEnabled;
  String? get userRole => _userRole;
  MediaStream? get localStream => _localStream;
  Map<String, MediaStream> get remoteStreams => _remoteStreams;
  Map<String, RTCVideoRenderer> get videoRenderers => _videoRenderers;
  int get connectedPeersCount => _connectedPeers.length;
  
  bool hasVideoEnabled(String userId) {
    final stream = _remoteStreams[userId];
    return stream != null && stream.getVideoTracks().isNotEmpty;
  }

  Future<void> connect(String serverUrl, String room, String userId, {bool audioOnly = true, String role = 'audience'}) async {
    try {
      // Check if already connected to the same room
      if (_isConnected && _socket != null && _socket!.connected && _currentRoom == room) {
        debugPrint('‚ö†Ô∏è [SimpleMediaSoupService] Already connected to room: $room, skipping reconnection');
        return;
      }
      
      // If connected to a different room or disconnected, clean up first
      if (_socket != null || _currentRoom != room) {
        debugPrint('üîÑ [SimpleMediaSoupService] Switching from room $_currentRoom to $room...');
        await _forceDisconnect(); // Use force disconnect for proper cleanup
        await Future.delayed(const Duration(milliseconds: 500)); // Longer delay for cleanup
      }
      
      _currentRoom = room;
      _userId = userId;
      _userRole = role;
      
      debugPrint('üîå [SimpleMediaSoupService] Connecting to MediaSoup server: $serverUrl');
      debugPrint('üë§ [SimpleMediaSoupService] User: $userId, Role: $role, Mode: ${audioOnly ? 'Audio-only' : 'Audio+Video'}');
      debugPrint('üè† [SimpleMediaSoupService] Room: $room');
      
      // Connect to Unified WebRTC server on Linode (simple signaling namespace)
      const serverPort = '3001'; // Unified server port
      const protocol = 'http'; // Use HTTP to avoid certificate issues
      final serverUri = '$protocol://$serverUrl:$serverPort/signaling'; // Simple WebRTC namespace
      debugPrint('üîå [SimpleMediaSoupService] Attempting to connect to: $serverUri');
      
      _socket = io.io(serverUri, <String, dynamic>{
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'timeout': 20000,
        'forceNew': true,
        'upgrade': true,
      });
      
      _setupSocketListeners();
      debugPrint('üì° Starting socket connection...');
      _socket!.connect();
      
      // Wait for connection
      await _waitForConnection();
      
      // Join room with role information (Simple WebRTC format)
      debugPrint('üè† [SimpleMediaSoupService] Joining Simple WebRTC room: $room');
      _joinSimpleRoom(room, userId, role);
      
      // Initialize local media
      debugPrint('üé§ [SimpleMediaSoupService] Initializing local media...');
      debugPrint('üé≠ User role: $role, audioOnly: $audioOnly');
      await _initializeMedia(audioOnly: audioOnly);
      
      // Initialize local media - peer connections will be created as needed
      
      _isConnected = true;
      debugPrint('‚úÖ [SimpleMediaSoupService] Connection established, calling onConnected callback');
      onConnected?.call();
      notifyListeners();
      
      debugPrint('‚úÖ [SimpleMediaSoupService] Connected to MediaSoup successfully');
      
    } catch (e) {
      debugPrint('‚ùå MediaSoup connection error: $e');
      onError?.call(e.toString());
    }
  }

  void _setupSocketListeners() {
    _socket!.on('connect', (_) {
      debugPrint('‚úÖ [SimpleMediaSoupService] Socket connected to signaling server');
      _mySocketId = _socket!.id;
      debugPrint('üÜî [SimpleMediaSoupService] My socket ID: $_mySocketId');
      debugPrint('üè† [SimpleMediaSoupService] Current room: $_currentRoom, User role: $_userRole');
      
      // Debug: Listen for any event
      _socket!.onAny((event, data) {
        debugPrint('üì® [SimpleMediaSoupService] Event received: $event with data: $data');
      });
    });
    
    _socket!.on('disconnect', (_) {
      debugPrint('üì° Disconnected from MediaSoup server');
      // Clean up all peer tracking
      _connectedPeers.clear();
      _mySocketId = null;
      debugPrint('üßπ Cleared all peer connections on disconnect');
      _handleDisconnection();
    });
    
    _socket!.on('connect_error', (error) {
      debugPrint('‚ùå Socket connection error: $error');
    });
    
    _socket!.on('error', (error) {
      debugPrint('‚ùå Socket error: $error');
    });
    
    // Handle existing peers when joining room
    _socket!.on('existing-peers', (data) async {
      final peers = data['peers'] as List;
      debugPrint('üë• Found ${peers.length} existing peers in room');
      
      for (final peer in peers) {
        final peerId = peer['peerId'];
        final userId = peer['userId'];
        final role = peer['role'];
        
        debugPrint('üë§ Existing peer: $peerId (User: $userId, Role: $role)');
        
        if (!_connectedPeers.contains(peerId)) {
          _connectedPeers.add(peerId);
          _peerMetadata[peerId] = {'userId': userId, 'role': role};
          
          // Create peer connection
          await _createPeerConnectionForPeer(peerId);
          onPeerJoined?.call(peerId, userId, role);
          
          // Initiate offer to existing peer
          await Future.delayed(const Duration(milliseconds: 500));
          await _createAndSendOffer(peerId);
        }
      }
      notifyListeners();
    });
    
    _socket!.on('peer-joined', (data) async {
      final peerId = data['peerId'];
      final userId = data['userId'];
      final role = data['role'];
      debugPrint('üë§ Peer joined: $peerId (User: $userId, Role: $role, my ID: $_mySocketId)');
      debugPrint('üîç PEER DEBUG: Current connected peers: $_connectedPeers');
      debugPrint('üîç PEER DEBUG: Current remote streams: ${_remoteStreams.keys.toList()}');
      
      // Skip if it's our own socket ID
      if (peerId == _mySocketId) {
        debugPrint('üö´ Ignoring self peer-joined event');
        return;
      }
      
      // Avoid duplicate processing of the same peer
      if (_connectedPeers.contains(peerId)) {
        debugPrint('‚ö†Ô∏è Peer $peerId already processed, skipping duplicate...');
        return;
      }
      
      _connectedPeers.add(peerId);
      debugPrint('‚úÖ Added peer $peerId to connected peers list');
      _peerMetadata[peerId] = {'userId': userId, 'role': role};
      debugPrint('üìù Added peer $peerId to connected peers. Total peers: ${_connectedPeers.length}');
      
      // Create a dedicated peer connection for this peer
      debugPrint('üé≠ Creating peer connection as $_userRole for peer $peerId (who is $role)');
      await _createPeerConnectionForPeer(peerId);
      
      onPeerJoined?.call(peerId, userId, role);
      notifyListeners(); // Update UI with new peer count
      
      // Always initiate offers when we detect a new peer - this ensures WebRTC starts
      // Let the WebRTC collision detection handle any conflicts
      debugPrint('üîç Socket ID comparison: My ID: $_mySocketId, Peer ID: $peerId');
      debugPrint('üéØ Always initiating call to ensure WebRTC connection starts');
      debugPrint('üé≠ As $_userRole, initiating offer to $role peer: $peerId');
      
      // Small delay to ensure both peers have processed the join
      await Future.delayed(const Duration(milliseconds: 500));
      await _createAndSendOffer(peerId);
    });
    
    _socket!.on('peer-left', (data) {
      final peerId = data['peerId'];
      debugPrint('üëã Peer left: $peerId');
      
      // Clean up peer tracking and connection
      _cleanupPeerConnection(peerId);
      
      onPeerLeft?.call(peerId);
      notifyListeners();
    });
    
    
    // Simple WebRTC signaling
    _socket!.on('offer', (data) async {
      final fromPeerId = data['from'];
      debugPrint('üì• Received offer from $fromPeerId (my ID: $_mySocketId)');
      debugPrint('üì• Offer data: $data');
      
      // Make sure this peer is tracked
      if (!_connectedPeers.contains(fromPeerId)) {
        debugPrint('üìù Adding $fromPeerId to connected peers (discovered via offer)');
        _connectedPeers.add(fromPeerId);
      }
      
      await _handleOffer(data, fromPeerId);
    });
    
    _socket!.on('answer', (data) async {
      final fromPeerId = data['from'];
      debugPrint('üì• Received answer from $fromPeerId (my ID: $_mySocketId)');
      
      // Make sure this peer is tracked
      if (!_connectedPeers.contains(fromPeerId)) {
        debugPrint('üìù Adding $fromPeerId to connected peers (discovered via answer)');
        _connectedPeers.add(fromPeerId);
      }
      
      await _handleAnswer(data, fromPeerId);
    });
    
    _socket!.on('ice-candidate', (data) async {
      final fromPeerId = data['from'];
      debugPrint('üßä Received ICE candidate from $fromPeerId (my ID: $_mySocketId)');
      
      // Make sure this peer is tracked
      if (!_connectedPeers.contains(fromPeerId)) {
        debugPrint('üìù Adding $fromPeerId to connected peers (discovered via ICE)');
        _connectedPeers.add(fromPeerId);
      }
      
      await _handleIceCandidate(data, fromPeerId);
    });
    
    // Audio-only mode - video state listeners removed
    
  }

  Future<void> _waitForConnection() async {
    final completer = Completer<void>();
    
    // Check if already connected
    if (_socket!.connected) {
      return Future.value();
    }
    
    // Set up one-time listener for connection
    late void Function(dynamic) connectHandler;
    connectHandler = (_) {
      _socket!.off('connect', connectHandler);
      completer.complete();
    };
    
    _socket!.on('connect', connectHandler);
    
    return completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () {
        _socket!.off('connect', connectHandler);
        throw Exception('Connection timeout');
      },
    );
  }

  void _joinMediaSoupRoom(String roomId, String userId, String role) {
    debugPrint('üì§ [SimpleMediaSoupService] Joining MediaSoup room: $roomId');
    
    // Send join request to MediaSoup server
    final joinData = {
      'roomId': roomId,
      'userId': userId,
      'role': role,
      'device': {
        'name': 'Flutter Client',
        'version': '1.0.0',
      },
    };
    debugPrint('üì§ [SimpleMediaSoupService] Sending join data: $joinData');
    _socket!.emit('join-room', joinData);
    
    debugPrint('üè† [SimpleMediaSoupService] MediaSoup room join request sent');
  }
  
  void _joinSimpleRoom(String roomId, String userId, String role) {
    debugPrint('üì§ [SimpleMediaSoupService] Joining simple WebRTC room: $roomId');
    
    // Send join request to signaling namespace (expects 'join-room' event)
    final joinData = {
      'roomId': roomId,
      'userId': userId,
      'role': role,
    };
    debugPrint('üì§ [SimpleMediaSoupService] Sending join-room data: $joinData');
    _socket!.emit('join-room', joinData);
    
    // Listen for join acknowledgment from signaling namespace
    _socket!.once('room-joined', (data) {
      debugPrint('‚úÖ [SimpleMediaSoupService] Successfully joined signaling room: $data');
    });
    
    debugPrint('üè† [SimpleMediaSoupService] Signaling room join request sent, waiting for peers...');
  }

  Future<void> _initializeMedia({bool audioOnly = true}) async {
    try {
      if (audioOnly) {
        debugPrint('üé§ [SimpleMediaSoupService] Audio-only mode for $_userRole - no microphone needed for audience');
        // For audience members in audio-only mode, we don't need local media
        // They will only receive streams from others
        if (_userRole == 'audience') {
          debugPrint('üé≠ Audience member - skipping local media setup, will only receive');
          // Don't call onLocalStream for audience members - they don't publish
          return;
        }
        debugPrint('üé§ [SimpleMediaSoupService] Requesting microphone permissions for $_userRole...');
      } else {
        debugPrint('üé• [SimpleMediaSoupService] Requesting camera and microphone permissions for $_userRole...');
      }
      
      // Initialize media stream based on mode
      final Map<String, dynamic> mediaConstraints = {
        'audio': {
          'echoCancellation': true,
          'noiseSuppression': true,
          'autoGainControl': true,
        },
        'video': audioOnly ? false : {
          'width': {'ideal': 640},
          'height': {'ideal': 480},
          'frameRate': {'ideal': 30},
          'facingMode': 'user', // Front camera
        },
      };
      
      _localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      onLocalStream?.call(_localStream!);
      
      // Set initial video state based on tracks available
      if (!audioOnly && _localStream!.getVideoTracks().isNotEmpty) {
        _isVideoEnabled = true;
        debugPrint('üé• Local media initialized - Audio+Video mode: ‚úÖ');
        debugPrint('üé§ Audio tracks: ${_localStream!.getAudioTracks().length}');
        debugPrint('üé• Video tracks: ${_localStream!.getVideoTracks().length}');
        
        // Log video track details
        for (final track in _localStream!.getVideoTracks()) {
          debugPrint('üé• Video track: ${track.id}, enabled: ${track.enabled}, kind: ${track.kind}');
        }
      } else {
        _isVideoEnabled = false;
        debugPrint('üé§ Local media initialized - Audio-only mode: ‚úÖ');
        debugPrint('üé§ Audio tracks: ${_localStream!.getAudioTracks().length}');
        if (audioOnly) {
          debugPrint('üé• Video disabled due to audioOnly=true');
        } else {
          debugPrint('üé• Video disabled - no video tracks available');
        }
      }
      
    } catch (e) {
      debugPrint('‚ùå Media initialization error: $e');
      
      // More specific error handling
      if (e.toString().contains('Permission denied') || 
          e.toString().contains('NotAllowedError') ||
          e.toString().contains('PermissionDeniedError')) {
        final deviceType = audioOnly ? 'microphone' : 'camera and microphone';
        throw Exception('$deviceType permission denied. Please enable $deviceType access in your device settings and try again.');
      } else if (e.toString().contains('NotFoundError') || 
                 e.toString().contains('DevicesNotFoundError')) {
        final deviceType = audioOnly ? 'microphone' : 'camera or microphone';
        throw Exception('No $deviceType found. Please check your device has working $deviceType hardware.');
      } else {
        final deviceType = audioOnly ? 'microphone' : 'camera and microphone';
        throw Exception('Failed to access $deviceType: $e');
      }
    }
  }
  
  // Video initialization removed - audio-only mode


  // Old single peer connection method removed - now using multi-peer architecture

  // Track connected peers to determine who should initiate
  final Set<String> _connectedPeers = {};
  final Map<String, Map<String, String?>> _peerMetadata = {}; // peerId -> {userId, role}
  String? _mySocketId;
  
  Future<void> _createPeerConnectionForPeer(String peerId) async {
    try {
      debugPrint('üîÑ [CreatePeerConnection] Starting creation for $peerId');
      
      // Check if we already have a peer connection for this peer
      if (_peerConnections.containsKey(peerId)) {
        final existingConnection = _peerConnections[peerId]!;
        final connectionState = await existingConnection.getConnectionState();
        if (connectionState != RTCPeerConnectionState.RTCPeerConnectionStateClosed) {
          debugPrint('‚ö†Ô∏è Peer connection for $peerId already exists and is active, skipping...');
          return;
        } else {
          debugPrint('üßπ Removing closed peer connection for $peerId');
          _cleanupPeerConnection(peerId);
        }
      }
      
      debugPrint('üîÑ [CreatePeerConnection] Creating RTCPeerConnection for $peerId');
      final configuration = {
        'iceServers': [
          {'urls': 'stun:stun.l.google.com:19302'},
        ]
      };
      
      final peerConnection = await createPeerConnection(configuration);
      _peerConnections[peerId] = peerConnection;
      debugPrint('‚úÖ [CreatePeerConnection] RTCPeerConnection created for $peerId');
      
      // Initialize ICE candidate buffer for this peer
      _iceCandidateBuffers[peerId] = [];
      _remoteDescriptionStates[peerId] = false;
      
      debugPrint('üîÑ [CreatePeerConnection] Setting up event handlers for $peerId');
      
      // Set up event handlers for this peer connection
      peerConnection.onIceCandidate = (candidate) {
        debugPrint('üßä Sending ICE candidate to $peerId');
        _socket!.emit('ice-candidate', {
          'candidate': candidate.candidate,
          'sdpMid': candidate.sdpMid,
          'sdpMLineIndex': candidate.sdpMLineIndex,
          'to': peerId,
          'from': _mySocketId, // Use socket ID for consistency
        });
      };
      
      peerConnection.onTrack = (event) async {
        debugPrint('üé¨ Received remote track from $peerId: ${event.track.kind}');
        debugPrint('üé≠ I am $_userRole, receiving from peer $peerId (user: ${_peerMetadata[peerId]?['userId']})');
        final stream = event.streams.first;
        
        // CRITICAL DEBUG: Check if stream is being reassigned
        if (_remoteStreams.containsKey(peerId)) {
          debugPrint('‚ö†Ô∏è STREAM REASSIGNMENT WARNING: Peer $peerId already has a stream!');
          debugPrint('‚ö†Ô∏è Previous stream ID: ${_remoteStreams[peerId]?.id}');
          debugPrint('‚ö†Ô∏è New stream ID: ${stream.id}');
        }
        
        _remoteStreams[peerId] = stream;
        debugPrint('‚úÖ Assigned stream ${stream.id} to peer $peerId');
        
        // Log all tracks in the stream
        debugPrint('üé¨ Stream has ${stream.getTracks().length} total tracks');
        debugPrint('üé§ Audio tracks: ${stream.getAudioTracks().length}');
        debugPrint('üé• Video tracks: ${stream.getVideoTracks().length}');
        debugPrint('üîç ALL CURRENT STREAMS: ${_remoteStreams.keys.map((k) => '$k->${_remoteStreams[k]?.id}').join(', ')}');
        
        // Initialize video renderer for this peer if video track exists
        if (stream.getVideoTracks().isNotEmpty) {
          final renderer = RTCVideoRenderer();
          await renderer.initialize();
          renderer.srcObject = stream;
          _videoRenderers[peerId] = renderer;
          debugPrint('üé• Video renderer initialized for peer: $peerId');
          
          // Log video track details
          for (final track in stream.getVideoTracks()) {
            debugPrint('üé• Remote video track: ${track.id}, enabled: ${track.enabled}');
          }
        } else {
          debugPrint('üé• No video tracks in remote stream from $peerId');
        }
        
        // Get metadata for this peer
        final metadata = _peerMetadata[peerId];
        final userId = metadata?['userId'];
        final role = metadata?['role'];
        
        debugPrint('üé¨ Remote stream metadata - userId: $userId, role: $role');
        onRemoteStream?.call(peerId, stream, userId, role);
        notifyListeners();
      };
      
      debugPrint('üîÑ [CreatePeerConnection] Adding local stream to peer $peerId');
      // Add local media tracks to this peer connection
      await _addLocalStreamToPeer(peerId);
      
      debugPrint('üîÑ [CreatePeerConnection] Processing buffered candidates for $peerId');
      // Process any buffered ICE candidates for this peer
      await _processBufferedCandidatesForPeer(peerId);
      
      debugPrint('üîó [CreatePeerConnection] Completed setup for $peerId');
      
    } catch (e) {
      debugPrint('‚ùå Failed to create peer connection for $peerId: $e');
    }
  }

  Future<void> _addLocalStreamToPeer(String peerId) async {
    try {
      final peerConnection = _peerConnections[peerId];
      if (peerConnection == null) {
        debugPrint('‚ùå [AddLocalStream] No peer connection found for $peerId');
        return;
      }
      
      // Add audio and video tracks
      if (_localStream != null) {
        final audioTracks = _localStream!.getAudioTracks();
        final videoTracks = _localStream!.getVideoTracks();
        
        // Debug current track states before adding
        debugPrint('üîç [AddLocalStream] Current local stream state before adding to $peerId:');
        for (final track in audioTracks) {
          debugPrint('  üé§ Audio track ${track.id}: enabled=${track.enabled}, muted=${track.muted}');
        }
        for (final track in videoTracks) {
          debugPrint('  üé• Video track ${track.id}: enabled=${track.enabled}, muted=${track.muted}');
        }
        
        debugPrint('üîÑ [AddLocalStream] Adding ${audioTracks.length} audio tracks to $peerId');
        for (final track in audioTracks) {
          await peerConnection.addTrack(track, _localStream!);
          debugPrint('‚ûï Added audio track ${track.id} (enabled: ${track.enabled}) to peer connection for $peerId');
        }
        
        debugPrint('üîÑ [AddLocalStream] Adding ${videoTracks.length} video tracks to $peerId');
        for (final track in videoTracks) {
          await peerConnection.addTrack(track, _localStream!);
          debugPrint('‚ûï Added video track ${track.id} (enabled: ${track.enabled}) to peer connection for $peerId');
        }
        
        // Verify tracks are still enabled after adding
        debugPrint('üîç [AddLocalStream] Local stream state after adding to $peerId:');
        for (final track in audioTracks) {
          debugPrint('  üé§ Audio track ${track.id}: enabled=${track.enabled}, muted=${track.muted}');
        }
        for (final track in videoTracks) {
          debugPrint('  üé• Video track ${track.id}: enabled=${track.enabled}, muted=${track.muted}');
        }
        
        debugPrint('üì± [AddLocalStream] Total tracks added to $peerId: ${audioTracks.length + videoTracks.length} (${audioTracks.length} audio, ${videoTracks.length} video)');
      } else {
        debugPrint('‚ö†Ô∏è [AddLocalStream] No local stream available for $peerId');
        
        // For audience members who don't have local video, still add transceivers to receive video
        if (_userRole == 'audience') {
          debugPrint('üé≠ Adding transceivers for audience member to receive video from $peerId');
          await peerConnection.addTransceiver(
            kind: RTCRtpMediaType.RTCRtpMediaTypeVideo,
            init: RTCRtpTransceiverInit(direction: TransceiverDirection.RecvOnly),
          );
          await peerConnection.addTransceiver(
            kind: RTCRtpMediaType.RTCRtpMediaTypeAudio,
            init: RTCRtpTransceiverInit(direction: TransceiverDirection.RecvOnly),
          );
        }
      }
      
      debugPrint('üì± [AddLocalStream] Media tracks added to peer connection for $peerId');
    } catch (e) {
      debugPrint('‚ùå [AddLocalStream] Error adding local stream to $peerId: $e');
      throw e; // Re-throw to fail peer connection creation
    }
  }
  
  void _cleanupPeerConnection(String peerId) {
    // Close and remove peer connection
    final peerConnection = _peerConnections.remove(peerId);
    if (peerConnection != null) {
      try {
        peerConnection.close();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error closing peer connection for $peerId: $e');
      }
    }
    
    // Remove streams and buffers
    final remoteStream = _remoteStreams.remove(peerId);
    if (remoteStream != null) {
      try {
        remoteStream.dispose();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error disposing remote stream for $peerId: $e');
      }
    }
    
    // Clean up video renderer
    final videoRenderer = _videoRenderers.remove(peerId);
    if (videoRenderer != null) {
      try {
        videoRenderer.dispose();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error disposing video renderer for $peerId: $e');
      }
    }
    
    _iceCandidateBuffers.remove(peerId);
    _remoteDescriptionStates.remove(peerId);
    _connectedPeers.remove(peerId);
    _peerMetadata.remove(peerId);
    
    debugPrint('üßπ Cleaned up peer connection for $peerId. Remaining peers: ${_connectedPeers.length}');
    notifyListeners(); // Update UI with new peer count
  }

  Future<void> _createAndSendOffer(String targetPeerId) async {
    try {
      final peerConnection = _peerConnections[targetPeerId];
      if (peerConnection == null) {
        debugPrint('‚ùå No peer connection found for $targetPeerId');
        return;
      }
      
      // Check if peer connection is closed
      final connectionState = await peerConnection.getConnectionState();
      debugPrint('üîç Connection state for $targetPeerId: $connectionState');
      
      if (connectionState == RTCPeerConnectionState.RTCPeerConnectionStateClosed) {
        debugPrint('‚ùå Cannot create offer - peer connection for $targetPeerId is closed');
        return;
      }
      
      // Check if peer connection is in a valid state for creating offers
      final signalingState = await peerConnection.getSignalingState();
      debugPrint('üîç Current signaling state for $targetPeerId: $signalingState');
      
      if (signalingState != RTCSignalingState.RTCSignalingStateStable) {
        debugPrint('‚ö†Ô∏è Cannot create offer - peer connection for $targetPeerId not in stable state: $signalingState');
        return;
      }
      
      final offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      
      debugPrint('üì§ Sending offer to $targetPeerId (SDP: ${offer.sdp?.substring(0, 50)}...)');
      final offerData = {
        'sdp': offer.sdp,
        'type': offer.type,
        'to': targetPeerId,
        'from': _mySocketId, // Use socket ID instead of user ID
      };
      debugPrint('üì§ Offer data: $offerData');
      _socket!.emit('offer', offerData);
    } catch (e) {
      debugPrint('‚ùå Error creating/sending offer to $targetPeerId: $e');
    }
  }

  Future<void> _handleOffer(Map<String, dynamic> data, String fromPeerId) async {
    debugPrint('üîç [HandleOffer] Looking for peer connection for $fromPeerId');
    debugPrint('üîç [HandleOffer] Available peer connections: ${_peerConnections.keys.toList()}');
    
    var peerConnection = _peerConnections[fromPeerId];
    if (peerConnection == null) {
      debugPrint('‚ùå No peer connection found for offer from $fromPeerId, creating one...');
      try {
        // Create peer connection if it doesn't exist
        await _createPeerConnectionForPeer(fromPeerId);
        peerConnection = _peerConnections[fromPeerId];
        
        if (peerConnection == null) {
          debugPrint('‚ùå Failed to create peer connection for $fromPeerId');
          return;
        }
        debugPrint('‚úÖ Successfully created peer connection for $fromPeerId');
      } catch (e) {
        debugPrint('‚ùå Error creating peer connection for offer from $fromPeerId: $e');
        return;
      }
    }
    
    try {
      // Check current signaling state before processing offer
      final signalingState = await peerConnection.getSignalingState();
      debugPrint('üì• Received offer from $fromPeerId, current signaling state: $signalingState');
      
      // Handle collision case - if we're already in have-local-offer state
      if (signalingState == RTCSignalingState.RTCSignalingStateHaveLocalOffer) {
        debugPrint('‚ö° Collision detected - both peers sent offers. Comparing socket IDs...');
        
        // The peer with higher socket ID should back down and accept the other's offer
        if (_mySocketId != null && _mySocketId!.compareTo(fromPeerId) > 0) {
          debugPrint('üîÑ I have higher socket ID ($_mySocketId > $fromPeerId), backing down and accepting their offer');
          // Reset to stable state first
          await peerConnection.setLocalDescription(await peerConnection.createAnswer());
        } else {
          debugPrint('üö´ I have lower socket ID ($_mySocketId < $fromPeerId), ignoring their offer');
          return;
        }
      }
      
      final offer = RTCSessionDescription(data['sdp'], data['type']);
      await peerConnection.setRemoteDescription(offer);
      
      // Mark remote description as set and process buffered candidates for this peer
      _remoteDescriptionStates[fromPeerId] = true;
      await _addBufferedIceCandidates(fromPeerId);
      
      final answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      
      debugPrint('üì§ Sending answer to $fromPeerId');
      _socket!.emit('answer', {
        'sdp': answer.sdp,
        'type': answer.type,
        'to': fromPeerId,
        'from': _mySocketId, // Use socket ID for consistency
      });
    } catch (e) {
      debugPrint('‚ùå Error handling offer from $fromPeerId: $e');
    }
  }

  Future<void> _handleAnswer(Map<String, dynamic> data, String fromPeerId) async {
    debugPrint('üîç [HandleAnswer] Looking for peer connection for $fromPeerId');
    debugPrint('üîç [HandleAnswer] Available peer connections: ${_peerConnections.keys.toList()}');
    
    var peerConnection = _peerConnections[fromPeerId];
    if (peerConnection == null) {
      debugPrint('‚ùå No peer connection found for answer from $fromPeerId');
      debugPrint('‚ö†Ô∏è Cannot create peer connection for incoming answer - answers require existing offers');
      return;
    }
    
    try {
      // Check signaling state before setting answer
      final signalingState = await peerConnection.getSignalingState();
      debugPrint('üîç [HandleAnswer] Current signaling state for $fromPeerId: $signalingState');
      
      if (signalingState != RTCSignalingState.RTCSignalingStateHaveLocalOffer) {
        debugPrint('‚ùå Cannot set answer - peer connection not in have-local-offer state: $signalingState');
        return;
      }
      
      final answer = RTCSessionDescription(data['sdp'], data['type']);
      await peerConnection.setRemoteDescription(answer);
      
      // Mark remote description as set and process buffered candidates for this peer
      _remoteDescriptionStates[fromPeerId] = true;
      await _addBufferedIceCandidates(fromPeerId);
      
      debugPrint('‚úÖ Answer set successfully for $fromPeerId');
    } catch (e) {
      debugPrint('‚ùå Error handling answer from $fromPeerId: $e');
    }
  }

  // Buffer ICE candidates until remote description is set (per peer)
  final Map<String, List<RTCIceCandidate>> _iceCandidateBuffers = {};
  final Map<String, bool> _remoteDescriptionStates = {};

  Future<void> _handleIceCandidate(Map<String, dynamic> data, String fromPeerId) async {
    debugPrint('üîç [HandleICE] Looking for peer connection for $fromPeerId');
    debugPrint('üîç [HandleICE] Available peer connections: ${_peerConnections.keys.toList()}');
    
    var peerConnection = _peerConnections[fromPeerId];
    if (peerConnection == null) {
      debugPrint('‚ùå No peer connection found for ICE candidate from $fromPeerId');
      debugPrint('‚ö†Ô∏è Buffering ICE candidate until peer connection is established');
      
      // Buffer the candidate for when the peer connection is created
      _iceCandidateBuffers[fromPeerId] ??= [];
      final candidate = RTCIceCandidate(
        data['candidate'],
        data['sdpMid'],
        data['sdpMLineIndex'],
      );
      _iceCandidateBuffers[fromPeerId]!.add(candidate);
      debugPrint('üßä ICE candidate buffered for $fromPeerId (${_iceCandidateBuffers[fromPeerId]!.length} total)');
      return;
    }
    
    final candidate = RTCIceCandidate(
      data['candidate'],
      data['sdpMid'],
      data['sdpMLineIndex'],
    );
    
    final isRemoteDescriptionSet = _remoteDescriptionStates[fromPeerId] ?? false;
    
    if (isRemoteDescriptionSet) {
      // Remote description is set, add candidate immediately
      try {
        await peerConnection.addCandidate(candidate);
        debugPrint('üßä ICE candidate added for $fromPeerId');
      } catch (e) {
        debugPrint('‚ùå Error adding ICE candidate for $fromPeerId: $e');
      }
    } else {
      // Buffer candidate for later
      _iceCandidateBuffers[fromPeerId] ??= [];
      _iceCandidateBuffers[fromPeerId]!.add(candidate);
      debugPrint('üßä ICE candidate buffered for $fromPeerId (${_iceCandidateBuffers[fromPeerId]!.length} total)');
    }
  }
  
  Future<void> _processBufferedCandidatesForPeer(String peerId) async {
    final buffer = _iceCandidateBuffers[peerId];
    if (buffer == null || buffer.isEmpty) return;
    
    debugPrint('üßä Processing ${buffer.length} buffered ICE candidates for $peerId (from peer creation)');
    final peerConnection = _peerConnections[peerId];
    if (peerConnection == null) return;
    
    // We can't add ICE candidates until remote description is set, so just leave them buffered
    // They will be processed when the remote description is set
    debugPrint('üßä ICE candidates remain buffered until remote description is set for $peerId');
  }

  Future<void> _addBufferedIceCandidates(String peerId) async {
    final buffer = _iceCandidateBuffers[peerId];
    final peerConnection = _peerConnections[peerId];
    
    if (buffer == null || peerConnection == null) return;
    
    debugPrint('üßä Adding ${buffer.length} buffered ICE candidates for $peerId');
    for (final candidate in buffer) {
      try {
        await peerConnection.addCandidate(candidate);
        debugPrint('üßä Buffered ICE candidate added for $peerId');
      } catch (e) {
        debugPrint('‚ùå Error adding buffered ICE candidate for $peerId: $e');
      }
    }
    buffer.clear();
  }

  Future<void> toggleMute() async {
    if (_localStream != null) {
      _isMuted = !_isMuted;
      _localStream!.getAudioTracks().forEach((track) {
        track.enabled = !_isMuted;
      });
      notifyListeners();
    }
  }

  Future<void> toggleLocalVideo() async {
    if (_localStream != null) {
      _isVideoEnabled = !_isVideoEnabled;
      _localStream!.getVideoTracks().forEach((track) {
        track.enabled = _isVideoEnabled;
      });
      debugPrint('üé• Local video ${_isVideoEnabled ? 'enabled' : 'disabled'}');
      notifyListeners();
    }
  }
  
  // All video-related methods removed - audio-only mode

  // Video renderer methods removed - audio-only mode

  void _handleDisconnection() {
    _isConnected = false;
    onDisconnected?.call();
    notifyListeners();
  }

  Future<void> _forceDisconnect() async {
    debugPrint('üßπ [SimpleMediaSoupService] Force disconnecting...');
    
    // Close all peer connections immediately
    for (final entry in _peerConnections.entries) {
      final peerId = entry.key;
      final peerConnection = entry.value;
      try {
        debugPrint('üîí Closing peer connection for $peerId');
        await peerConnection.close();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error closing peer connection for $peerId: $e');
      }
    }
    _peerConnections.clear();
    
    // Stop local audio stream
    if (_localStream != null) {
      _localStream!.getTracks().forEach((track) {
        try {
          track.stop();
        } catch (e) {
          debugPrint('‚ö†Ô∏è Error stopping track: $e');
        }
      });
      _localStream?.dispose();
      _localStream = null;
    }
    
    // Clear remote streams and video renderers
    for (final entry in _remoteStreams.entries) {
      try {
        entry.value.dispose();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error disposing remote stream for ${entry.key}: $e');
      }
    }
    _remoteStreams.clear();
    
    // Clean up video renderers
    for (final entry in _videoRenderers.entries) {
      try {
        await entry.value.dispose();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error disposing video renderer for ${entry.key}: $e');
      }
    }
    _videoRenderers.clear();
    
    // Disconnect socket
    if (_socket != null) {
      try {
        _socket!.disconnect();
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error disconnecting socket: $e');
      }
      _socket = null;
    }
    
    // Clear state
    _isConnected = false;
    _currentRoom = null;
    _remoteDescriptionStates.clear();
    _iceCandidateBuffers.clear();
    _connectedPeers.clear();
    _peerMetadata.clear();
    _mySocketId = null;
    
    debugPrint('‚úÖ [SimpleMediaSoupService] Force disconnect complete');
  }

  Future<void> disconnect() async {
    if (_isDisposed) return;
    
    await _forceDisconnect();
    
    // Reset callbacks
    onLocalStream = null;
    onRemoteStream = null;
    onPeerJoined = null;
    onPeerLeft = null;
    onError = null;
    onConnected = null;
    onDisconnected = null;
    
    notifyListeners();
  }

  @override
  void dispose() {
    if (_isDisposed) return;
    
    _isDisposed = true;
    disconnect();
    super.dispose();
  }
}