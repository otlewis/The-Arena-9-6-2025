import 'dart:async';
import 'package:appwrite/appwrite.dart';
import '../models/gift.dart';
import '../models/received_gift.dart';
import 'appwrite_service.dart';
import 'coin_service.dart';
import '../core/logging/app_logger.dart';

class GiftService {
  static final GiftService _instance = GiftService._internal();
  factory GiftService() => _instance;
  GiftService._internal();

  final AppwriteService _appwrite = AppwriteService();
  final CoinService _coinService = CoinService();
  
  // Stream controllers for real-time updates
  final StreamController<List<ReceivedGift>> _receivedGiftsController = 
      StreamController<List<ReceivedGift>>.broadcast();
  final StreamController<ReceivedGift> _newGiftController = 
      StreamController<ReceivedGift>.broadcast();
  
  // Getters for streams
  Stream<List<ReceivedGift>> get receivedGiftsStream => _receivedGiftsController.stream;
  Stream<ReceivedGift> get newGiftStream => _newGiftController.stream;
  
  RealtimeSubscription? _giftsSubscription;
  String? _currentUserId;

  /// Initialize gift service for a user
  Future<void> initialize(String userId) async {
    _currentUserId = userId;
    
    // Add a small delay to ensure AppwriteService is ready
    await Future.delayed(const Duration(milliseconds: 500));
    
    try {
      await _setupRealtimeSubscription();
      await _loadReceivedGifts();
    } catch (e) {
      AppLogger().error('Error initializing GiftService: $e');
      // Schedule retry after a delay
      Future.delayed(const Duration(seconds: 2), () async {
        try {
          await _setupRealtimeSubscription();
          await _loadReceivedGifts();
        } catch (retryError) {
          AppLogger().error('Retry failed for GiftService initialization: $retryError');
        }
      });
    }
  }

  /// Set up real-time subscription for new gifts
  Future<void> _setupRealtimeSubscription() async {
    if (_currentUserId == null) return;
    
    try {
      _giftsSubscription?.close();
      
      // Ensure AppwriteService is ready before using realtime
      if (_appwrite.realtimeInstance == null) {
        throw Exception('AppwriteService realtime instance not ready');
      }
      
      _giftsSubscription = _appwrite.realtimeInstance.subscribe([
        'databases.arena_db.collections.received_gifts.documents'
      ]);

      _giftsSubscription?.stream.listen((response) {
        AppLogger().debug('Gift real-time update: ${response.events}');
        
        if (response.events.contains('databases.arena_db.collections.received_gifts.documents.*.create')) {
          final payload = response.payload;
          if (payload['receiverId'] == _currentUserId) {
            final newGift = ReceivedGift.fromJson(payload);
            _newGiftController.add(newGift);
            _loadReceivedGifts(); // Refresh the list
          }
        } else if (response.events.contains('databases.arena_db.collections.received_gifts.documents.*.update') ||
                   response.events.contains('databases.arena_db.collections.received_gifts.documents.*.delete')) {
          _loadReceivedGifts(); // Refresh the list
        }
      });
    } catch (e) {
      AppLogger().error('Error setting up gift real-time subscription: $e');
    }
  }

  /// Send a gift to another user
  Future<bool> sendGift({
    required String giftId,
    required String receiverId,
    required String receiverName,
    String? message,
    String? roomId,
    String? roomType,
    String? roomName,
  }) async {
    try {
      if (_currentUserId == null) {
        throw Exception('User not authenticated');
      }

      final currentUser = await _appwrite.getCurrentUser();
      if (currentUser == null) {
        throw Exception('Unable to get current user');
      }

      final gift = GiftConstants.getGiftById(giftId);
      if (gift == null) {
        throw Exception('Gift not found');
      }

      // Check if user has enough coins
      final hasEnoughCoins = await _coinService.hasEnoughCoins(_currentUserId!, gift.cost.toInt());
      if (!hasEnoughCoins) {
        throw Exception('Insufficient coins');
      }

      // Get current user profile for sender info
      final senderProfile = await _appwrite.getUserProfile(_currentUserId!);
      final senderName = senderProfile?.name ?? currentUser.name;
      final senderAvatar = senderProfile?.avatar;

      // Create the received gift document
      final receivedGift = ReceivedGift(
        id: '', // Will be generated by Appwrite
        giftId: giftId,
        senderId: _currentUserId!,
        senderName: senderName,
        senderAvatar: senderAvatar,
        receiverId: receiverId,
        receiverName: receiverName,
        message: message,
        roomId: roomId,
        roomType: roomType,
        roomName: roomName,
        createdAt: DateTime.now(),
        isRead: false,
        isNotified: false,
      );

      // Save to Appwrite
      await _appwrite.databases.createDocument(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        documentId: ID.unique(),
        data: receivedGift.toJson(),
      );

      // Deduct coins from sender
      final coinDeducted = await _coinService.deductCoins(_currentUserId!, gift.cost.toInt());
      if (!coinDeducted) {
        throw Exception('Failed to deduct coins');
      }

      AppLogger().debug('Gift sent successfully: $giftId to $receiverId');
      return true;
    } catch (e) {
      AppLogger().error('Error sending gift: $e');
      return false;
    }
  }

  /// Load received gifts for current user
  Future<void> _loadReceivedGifts() async {
    if (_currentUserId == null) return;
    
    try {
      final response = await _appwrite.databases.listDocuments(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        queries: [
          Query.equal('receiverId', _currentUserId!),
          Query.orderDesc('\$createdAt'),
          Query.limit(50), // Limit to recent 50 gifts
        ],
      );

      final gifts = response.documents
          .map((doc) => ReceivedGift.fromJson(doc.data))
          .toList();

      _receivedGiftsController.add(gifts);
      AppLogger().debug('Loaded ${gifts.length} received gifts');
    } catch (e) {
      AppLogger().error('Error loading received gifts: $e');
      _receivedGiftsController.add([]);
    }
  }

  /// Mark gifts as read
  Future<void> markGiftAsRead(String giftId) async {
    try {
      await _appwrite.databases.updateDocument(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        documentId: giftId,
        data: {'isRead': true},
      );
      
      // Refresh the list
      await _loadReceivedGifts();
    } catch (e) {
      AppLogger().error('Error marking gift as read: $e');
    }
  }

  /// Mark all gifts as read
  Future<void> markAllGiftsAsRead() async {
    if (_currentUserId == null) return;
    
    try {
      // Get all unread gifts
      final response = await _appwrite.databases.listDocuments(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        queries: [
          Query.equal('receiverId', _currentUserId!),
          Query.equal('isRead', false),
        ],
      );

      // Mark each as read
      for (final doc in response.documents) {
        await _appwrite.databases.updateDocument(
          databaseId: 'arena_db',
          collectionId: 'received_gifts',
          documentId: doc.$id,
          data: {'isRead': true},
        );
      }
      
      // Refresh the list
      await _loadReceivedGifts();
    } catch (e) {
      AppLogger().error('Error marking all gifts as read: $e');
    }
  }

  /// Get unread gift count
  Future<int> getUnreadGiftCount() async {
    if (_currentUserId == null) return 0;
    
    try {
      final response = await _appwrite.databases.listDocuments(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        queries: [
          Query.equal('receiverId', _currentUserId!),
          Query.equal('isRead', false),
        ],
      );

      return response.documents.length;
    } catch (e) {
      AppLogger().error('Error getting unread gift count: $e');
      return 0;
    }
  }

  /// Get gift statistics for a user
  Future<Map<String, int>> getGiftStats(String userId) async {
    try {
      final response = await _appwrite.databases.listDocuments(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        queries: [
          Query.equal('receiverId', userId),
        ],
      );

      final gifts = response.documents
          .map((doc) => ReceivedGift.fromJson(doc.data))
          .toList();

      int totalGifts = gifts.length;
      int totalValue = 0;
      Map<String, int> giftCounts = {};

      for (final receivedGift in gifts) {
        final gift = receivedGift.giftDetails;
        if (gift != null) {
          totalValue += gift.cost.toInt();
          giftCounts[gift.id] = (giftCounts[gift.id] ?? 0) + 1;
        }
      }

      return {
        'totalGifts': totalGifts,
        'totalValue': totalValue,
        'uniqueGifts': giftCounts.length,
      };
    } catch (e) {
      AppLogger().error('Error getting gift stats: $e');
      return {'totalGifts': 0, 'totalValue': 0, 'uniqueGifts': 0};
    }
  }

  /// Get most received gifts for display
  Future<List<MapEntry<Gift, int>>> getMostReceivedGifts(String userId, {int limit = 5}) async {
    try {
      final response = await _appwrite.databases.listDocuments(
        databaseId: 'arena_db',
        collectionId: 'received_gifts',
        queries: [
          Query.equal('receiverId', userId),
        ],
      );

      final gifts = response.documents
          .map((doc) => ReceivedGift.fromJson(doc.data))
          .toList();

      Map<String, int> giftCounts = {};
      for (final receivedGift in gifts) {
        giftCounts[receivedGift.giftId] = (giftCounts[receivedGift.giftId] ?? 0) + 1;
      }

      // Sort by count and take top gifts
      final sortedGifts = giftCounts.entries
          .map((entry) {
            final gift = GiftConstants.getGiftById(entry.key);
            return gift != null ? MapEntry(gift, entry.value) : null;
          })
          .where((entry) => entry != null)
          .cast<MapEntry<Gift, int>>()
          .toList()
        ..sort((a, b) => b.value.compareTo(a.value));

      return sortedGifts.take(limit).toList();
    } catch (e) {
      AppLogger().error('Error getting most received gifts: $e');
      return [];
    }
  }

  /// Dispose resources
  void dispose() {
    _giftsSubscription?.close();
    _receivedGiftsController.close();
    _newGiftController.close();
  }
}