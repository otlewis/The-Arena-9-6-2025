import 'dart:async';
import 'package:flutter/material.dart';
import 'package:socket_io_client/socket_io_client.dart' as io;
import 'package:mediasfu_mediasoup_client/mediasfu_mediasoup_client.dart';

/// Smart WebRTC service that uses MediaSoup SFU for all room types
/// with role-based media permissions
class SmartWebRTCService extends ChangeNotifier {
  static final SmartWebRTCService _instance = SmartWebRTCService._internal();
  factory SmartWebRTCService() => _instance;
  SmartWebRTCService._internal();

  // Socket.IO connection
  io.Socket? _socket;
  
  // MediaSoup client objects
  Device? _device;
  Transport? _sendTransport;
  Transport? _recvTransport;
  final Map<String, Producer> _producers = {};
  final Map<String, Consumer> _consumers = {};
  
  // WebRTC media
  MediaStream? _localStream;
  final Map<String, MediaStream> _remoteStreams = {};
  final Map<String, RTCVideoRenderer> _videoRenderers = {};
  
  // State
  bool _isConnected = false;
  bool _isMuted = false;
  bool _isVideoEnabled = false;
  bool _isDisposed = false;
  String? _currentRoom;
  String? _currentRoomType;
  String? _userRole;
  String? _myPeerId;
  String? _userId;
  bool _canPublishMedia = false;
  Map<String, dynamic>? _routerRtpCapabilities;
  
  // Callbacks
  Function(MediaStream)? onLocalStream;
  Function(String peerId, MediaStream stream, String? userId, String? role)? onRemoteStream;
  Function(String peerId, String? userId, String? role)? onPeerJoined;
  Function(String peerId)? onPeerLeft;
  Function(String)? onError;
  Function()? onConnected;
  Function()? onDisconnected;
  Function(String userId, bool isSharing)? onRemoteScreenShareChanged;
  
  // Getters
  bool get isConnected => _isConnected;
  bool get isMuted => _isMuted;
  bool get isLocalVideoEnabled => _isVideoEnabled;
  String? get userRole => _userRole;
  MediaStream? get localStream => _localStream;
  Map<String, MediaStream> get remoteStreams => _remoteStreams;
  Map<String, RTCVideoRenderer> get videoRenderers => _videoRenderers;
  int get connectedPeersCount => _consumers.length;
  bool get hasVideoEnabled => _isVideoEnabled;
  bool get canPublishMedia => _canPublishMedia;
  
  /// Determine if role can publish media based on room type
  bool _shouldPublishMedia(String role, String roomType) {
    switch (roomType) {
      case 'arena':
        // In Arena: moderator, debaters (affirmative/negative) and judges can publish
        return role == 'moderator' || 
               role == 'affirmative' || 
               role == 'negative' || 
               role == 'affirmative2' || 
               role == 'negative2' || 
               role == 'judge';
      
      case 'debate_discussion':
        // In Debates & Discussions: moderator and speakers can publish
        return role == 'moderator' || role == 'speaker';
      
      case 'open_discussion':
        // In Open Discussion: moderator and speakers can publish
        return role == 'moderator' || role == 'speaker';
      
      default:
        // Default: only non-audience can publish
        return role != 'audience';
    }
  }
  
  /// Test if MediaSoup server is reachable
  Future<bool> testServerConnectivity(String serverUrl) async {
    try {
      debugPrint('üîç Testing MediaSoup server connectivity...');
      final uri = serverUrl.startsWith('http') ? serverUrl : 'http://$serverUrl';
      
      final testSocket = io.io(uri, <String, dynamic>{
        'transports': ['polling'],
        'autoConnect': false,
        'timeout': 10000,
      });
      
      final completer = Completer<bool>();
      
      testSocket.once('connect', (_) {
        debugPrint('‚úÖ Server connectivity test successful');
        testSocket.disconnect();
        completer.complete(true);
      });
      
      testSocket.once('connect_error', (error) {
        debugPrint('‚ùå Server connectivity test failed: $error');
        testSocket.disconnect();
        completer.complete(false);
      });
      
      testSocket.connect();
      
      return await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          testSocket.disconnect();
          return false;
        },
      );
    } catch (e) {
      debugPrint('‚ùå Connectivity test error: $e');
      return false;
    }
  }

  /// Smart connect method that handles role-based permissions
  Future<void> connect(
    String serverUrl, 
    String room, 
    String userId, {
    bool audioOnly = true, 
    String role = 'audience',
    String roomType = 'open_discussion',
  }) async {
    try {
      debugPrint('üöÄ Smart WebRTC connect() called with:');
      debugPrint('   serverUrl: $serverUrl');
      debugPrint('   room: $room');
      debugPrint('   userId: $userId');
      debugPrint('   role: $role');
      debugPrint('   roomType: $roomType');
      debugPrint('   audioOnly: $audioOnly');
      
      // Determine if this role can publish media
      _canPublishMedia = _shouldPublishMedia(role, roomType);
      debugPrint('   canPublishMedia: $_canPublishMedia (role: $role, roomType: $roomType)');
      
      // Check if already connected
      if (_isConnected && _socket != null && _socket!.connected && _currentRoom == room) {
        debugPrint('‚ö†Ô∏è Already connected to room: $room');
        return;
      }
      
      // Clean up if switching rooms
      if (_socket != null) {
        debugPrint('üßπ Cleaning up existing connection');
        await _forceDisconnect();
        await Future.delayed(const Duration(milliseconds: 500));
      }
      
      _currentRoom = room;
      _currentRoomType = roomType;
      _userRole = role;
      _userId = userId;
      
      // Re-set media permissions after cleanup (cleanup resets _canPublishMedia to false)
      _canPublishMedia = _shouldPublishMedia(role, roomType);
      debugPrint('üîÑ Media permissions re-set after cleanup: $_canPublishMedia (role: $role, roomType: $roomType)');
      
      // Test server connectivity first
      debugPrint('üîç Running connectivity pre-check...');
      final isReachable = await testServerConnectivity(serverUrl);
      if (!isReachable) {
        throw Exception('MediaSoup server is not reachable from this network. Please check your internet connection or try a different network.');
      }
      
      // Connect to MediaSoup server
      final serverUri = serverUrl.startsWith('http') 
          ? serverUrl 
          : 'http://$serverUrl';
      debugPrint('üîå Connecting to MediaSoup server: $serverUri');
      debugPrint('üì° Using polling-first transport for mobile compatibility...');
      debugPrint('üîç Network diagnostics:');
      debugPrint('   - Target: $serverUri');
      debugPrint('   - This may fail on mobile networks or restrictive WiFi');
      debugPrint('   - Server must be reachable from your device network');
      
      _socket = io.io(serverUri, <String, dynamic>{
        'transports': ['polling', 'websocket'], // Try polling first for Android compatibility
        'autoConnect': false,  // Don't auto-connect, we'll do it manually
        'forceNew': true,
        'timeout': 45000, // Increased timeout for mobile networks
        'upgrade': true,
        'rememberUpgrade': false,
      });
      
      debugPrint('üì° Socket created');
      
      _setupSocketListeners();
      
      debugPrint('üîå Attempting socket connection...');
      _socket!.connect();
      debugPrint('üì° Socket.connect() called');
      
      // Wait for connection
      debugPrint('‚è≥ Waiting for socket connection...');
      await _waitForConnection();
      debugPrint('‚úÖ Socket connection confirmed');
      
      // Join room with role information FIRST (this creates the room and router)
      debugPrint('üö™ About to join MediaSoup room...');
      await _joinRoom(room, userId, role, roomType);
      debugPrint('‚úÖ Successfully joined MediaSoup room');
      
      // Initialize MediaSoup device AFTER joining (now room exists)
      debugPrint('üì± About to initialize MediaSoup device...');
      await _initializeDevice();
      debugPrint('‚úÖ MediaSoup device initialized successfully');
      
      // Only initialize media if role can publish  
      debugPrint('üîç Checking media permissions: canPublish=$_canPublishMedia, role=$role, roomType=$roomType');
      if (_canPublishMedia) {
        debugPrint('üé§ Role "$role" can publish media - initializing...');
        await _initializeMedia(audioOnly: audioOnly);
        await _createSendTransport();
        await _produceTracks();
      } else {
        debugPrint('üîá Role "$role" is receive-only - skipping media initialization');
      }
      
      // Create receive transport for consuming other participants
      await _createRecvTransport();
      
      _isConnected = true;
      onConnected?.call();
      notifyListeners();
      
    } catch (e) {
      debugPrint('‚ùå Smart WebRTC connection error: $e');
      
      // Check if this is a network connectivity issue
      if (e.toString().contains('Socket connection timeout') || 
          e.toString().contains('Connection error')) {
        debugPrint('üåê Network connectivity issue detected');
        debugPrint('üí° Troubleshooting suggestions:');
        debugPrint('   1. Check if you\'re on a restrictive network (corporate WiFi, mobile data)');
        debugPrint('   2. Try switching between WiFi and mobile data');
        debugPrint('   3. MediaSoup server may need to be accessible from public internet');
        debugPrint('   4. Consider using a VPN or different network');
        
        // Provide a more user-friendly error message
        onError?.call('Unable to connect to audio server. Please check your network connection and try again.');
      } else {
        onError?.call(e.toString());
      }
      rethrow;
    }
  }
  
  Future<void> _initializeDevice() async {
    try {
      debugPrint('üì± Initializing MediaSoup device...');
      _device = Device();
      
      // Use RTP capabilities we already received during room joining
      if (_routerRtpCapabilities == null) {
        throw Exception('Router RTP capabilities not available - room may not have been joined properly');
      }
      
      debugPrint('üì° Using stored router RTP capabilities');
      
      // Load device with router capabilities (convert Map to RtpCapabilities)
      debugPrint('üìä Router RTP capabilities type: ${_routerRtpCapabilities.runtimeType}');
      debugPrint('üìä Router RTP capabilities keys: ${_routerRtpCapabilities!.keys.toList()}');
      
      // Create RtpCapabilities from the Map
      final rtpCapabilities = RtpCapabilities.fromMap(_routerRtpCapabilities!);
      
      await _device!.load(routerRtpCapabilities: rtpCapabilities);
      debugPrint('‚úÖ MediaSoup device loaded');
      
    } catch (e) {
      debugPrint('‚ùå Device initialization error: $e');
      rethrow;
    }
  }
  
  Future<void> _joinRoom(String room, String userId, String role, String roomType) async {
    try {
      debugPrint('üö™ Joining MediaSoup room: $room as $role in $roomType');
      
      final completer = Completer<void>();
      _socket!.once('room-joined', (data) {
        debugPrint('üì• Room joined: $data');
        _myPeerId = data['myPeerId'] ?? _socket!.id;
        
        // Store router RTP capabilities from room-joined response
        if (data['rtpCapabilities'] != null) {
          _routerRtpCapabilities = data['rtpCapabilities'];
          debugPrint('üì° Stored router RTP capabilities from room-joined response');
        }
        
        // Get existing participants if any
        if (data['participants'] != null) {
          for (final participant in data['participants']) {
            final peerId = participant['peerId'];
            final pUserId = participant['userId'];
            final pRole = participant['role'];
            debugPrint('   Existing participant: $pUserId ($pRole)');
            onPeerJoined?.call(peerId, pUserId, pRole);
          }
        }
        
        // Handle existing producers from room-joined response
        if (data['existingProducers'] != null) {
          debugPrint('üéß Found ${data['existingProducers'].length} existing producers');
          
          // Store existing producers to consume after transport setup
          final existingProducers = data['existingProducers'] as List;
          
          // Schedule consumption after transport is ready
          Future.delayed(const Duration(milliseconds: 500), () async {
            for (final producer in existingProducers) {
              debugPrint('üéß Consuming existing producer: ${producer['producerId']} from ${producer['userId']} (${producer['role']})');
              
              // Simulate newProducer event for existing producers
              await _consumeProducer({
                'producerId': producer['producerId'],
                'peerId': producer['peerId'],
                'userId': producer['userId'],
                'role': producer['role'],
                'kind': producer['kind'],
              });
            }
          });
        }
        
        completer.complete();
      });
      
      _socket!.emit('join-room', {
        'roomId': room,
        'userId': userId,
        'role': role,
        'roomType': roomType,
        'canPublish': _canPublishMedia,
      });
      
      await completer.future.timeout(
        const Duration(seconds: 20),
        onTimeout: () => throw TimeoutException('Failed to join room'),
      );
      
    } catch (e) {
      debugPrint('‚ùå Room join error: $e');
      rethrow;
    }
  }
  
  Future<void> _createSendTransport() async {
    if (!_canPublishMedia) {
      debugPrint('‚ö†Ô∏è Skipping send transport - role cannot publish');
      return;
    }
    
    try {
      debugPrint('üì§ Creating send transport...');
      
      final response = await _rpcRequest('createWebRtcTransport', {
        'roomId': _currentRoom,
        'direction': 'send',
      });
      
      _sendTransport = _device!.createSendTransport(
        id: response['id'],
        iceParameters: IceParameters.fromMap(response['iceParameters']),
        iceCandidates: (response['iceCandidates'] as List)
            .map((candidate) => IceCandidate.fromMap(candidate))
            .toList(),
        dtlsParameters: DtlsParameters.fromMap(response['dtlsParameters']),
      );
      
      _sendTransport!.on('connect', (data) async {
        debugPrint('üîó Send transport connect event triggered!');
        debugPrint('üîó Transport ID: ${_sendTransport!.id}');
        debugPrint('üîó DTLS Parameters received: ${data['dtlsParameters'] != null}');
        
        try {
          await _rpcRequest('connectWebRtcTransport', {
            'transportId': _sendTransport!.id,
            'dtlsParameters': data['dtlsParameters'],
          });
          debugPrint('‚úÖ Send transport connected to server');
          data['callback']();
        } catch (e) {
          debugPrint('‚ùå Send transport connection failed: $e');
          data['errback'](e);
        }
      });
      
      _sendTransport!.on('produce', (data) async {
        debugPrint('üé¨ PRODUCE EVENT TRIGGERED!');
        debugPrint('üé¨ Track kind: ${data['kind']}');
        debugPrint('üé¨ RTP Parameters: ${data['rtpParameters'] != null}');
        debugPrint('üé¨ App Data: ${data['appData']}');
        
        try {
          final response = await _rpcRequest('produce', {
            'roomId': _currentRoom,
            'transportId': _sendTransport!.id,
            'kind': data['kind'],
            'rtpParameters': data['rtpParameters'],
            'appData': {
              ...data['appData'],
              'userId': _userId,
              'role': _userRole,
            },
          });
          
          final producerId = response['producerId'];
          debugPrint('‚úÖ Producer created on server: $producerId');
          
          data['callback']({'id': producerId});
          
        } catch (e) {
          debugPrint('‚ùå Production failed: $e');
          data['errback'](e);
        }
      });
      
      debugPrint('‚úÖ Send transport created');
      
      // If we have local stream with audio tracks, try to trigger production immediately
      if (_localStream != null) {
        final audioTracks = _localStream!.getAudioTracks();
        if (audioTracks.isNotEmpty) {
          debugPrint('üé§ Triggering immediate audio production...');
          try {
            // Manually create audio producer to force transport connection
            final response = await _rpcRequest('produce', {
              'roomId': _currentRoom,
              'transportId': _sendTransport!.id,
              'kind': 'audio',
              'rtpParameters': {
                // Basic RTP parameters for audio
                'codecs': [
                  {
                    'mimeType': 'audio/opus',
                    'clockRate': 48000,
                    'channels': 2,
                    'payloadType': 111,
                  }
                ],
                'encodings': [
                  {
                    'ssrc': DateTime.now().millisecondsSinceEpoch,
                  }
                ],
                'headerExtensions': [],
                'rtcp': {
                  'cname': 'user-$_userId',
                  'reducedSize': true,
                },
              },
              'appData': {
                'userId': _userId,
                'role': _userRole,
                'mediaType': 'audio',
              },
            });
            
            final producerId = response['producerId'];
            debugPrint('‚úÖ Manual audio producer created: $producerId');
            
          } catch (e) {
            debugPrint('‚ö†Ô∏è Manual audio production failed: $e');
            debugPrint('üì° Will rely on transport events for production');
          }
        }
      }
      
    } catch (e) {
      debugPrint('‚ùå Send transport creation error: $e');
      rethrow;
    }
  }
  
  Future<void> _createRecvTransport() async {
    try {
      debugPrint('üì• Creating receive transport...');
      
      if (_device == null) {
        throw Exception('Device not initialized - cannot create receive transport');
      }
      
      final response = await _rpcRequest('createWebRtcTransport', {
        'roomId': _currentRoom,
        'direction': 'recv',
      });
      
      _recvTransport = _device!.createRecvTransport(
        id: response['id'],
        iceParameters: IceParameters.fromMap(response['iceParameters']),
        iceCandidates: (response['iceCandidates'] as List)
            .map((candidate) => IceCandidate.fromMap(candidate))
            .toList(),
        dtlsParameters: DtlsParameters.fromMap(response['dtlsParameters']),
      );
      
      _recvTransport!.on('connect', (data) async {
        debugPrint('üîó Receive transport connecting...');
        await _rpcRequest('connectWebRtcTransport', {
          'transportId': _recvTransport!.id,
          'dtlsParameters': data['dtlsParameters'],
        });
        data['callback']();
      });
      
      debugPrint('‚úÖ Receive transport created');
      
      // Existing producers are handled via the room-joined response
      debugPrint('üí° Existing producers will be consumed from room-joined response');
      
    } catch (e) {
      debugPrint('‚ùå Receive transport creation error: $e');
      rethrow;
    }
  }
  
  Future<void> _produceTracks() async {
    if (!_canPublishMedia || _localStream == null || _sendTransport == null) {
      debugPrint('‚ö†Ô∏è Cannot produce tracks - canPublish: $_canPublishMedia, hasStream: ${_localStream != null}, hasTransport: ${_sendTransport != null}');
      return;
    }
    
    try {
      debugPrint('üé§ Producing tracks for role: $_userRole');
      
      // Produce audio tracks
      final audioTracks = _localStream!.getAudioTracks();
      if (audioTracks.isNotEmpty) {
        debugPrint('üé§ Audio tracks available for production: ${audioTracks.length}');
        
        final audioTrack = audioTracks.first;
        debugPrint('üé§ Producing audio track: ID=${audioTrack.id}, enabled=${audioTrack.enabled}');
        
        // The transport events will handle the actual production
        // Just log that we have audio tracks ready for production
        debugPrint('üé§ Audio tracks ready for production via transport events');
        debugPrint('üé§ First audio track: ID=${audioTrack.id}, enabled=${audioTrack.enabled}');
        
        // The produce event handler in _createSendTransport() will be triggered
        // automatically when MediaSoup is ready to produce audio
      }
      
      // Produce video if enabled
      if (_isVideoEnabled) {
        final videoTracks = _localStream!.getVideoTracks();
        if (videoTracks.isNotEmpty) {
          debugPrint('üé• Would produce video track (temporarily disabled for API compatibility)');
          // TODO: Implement proper video producer when API is fixed
        }
      }
      
    } catch (e) {
      debugPrint('‚ùå Track production error: $e');
    }
  }
  
  Future<void> _initializeMedia({required bool audioOnly}) async {
    if (!_canPublishMedia) {
      debugPrint('‚ö†Ô∏è Skipping media initialization - role cannot publish');
      return;
    }
    
    try {
      debugPrint('üé• Initializing media for role: $_userRole - audioOnly: $audioOnly');
      
      final Map<String, dynamic> mediaConstraints = {
        'audio': {
          'echoCancellation': true,
          'noiseSuppression': true,
          'autoGainControl': true,
        },
        'video': audioOnly ? false : {
          'width': {'ideal': 640},
          'height': {'ideal': 480},
          'frameRate': {'ideal': 30},
          'facingMode': 'user',
        },
      };
      
      _localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      onLocalStream?.call(_localStream!);
      
      if (!audioOnly && _localStream!.getVideoTracks().isNotEmpty) {
        _isVideoEnabled = true;
        debugPrint('üé• Local video initialized');
      }
      
      debugPrint('‚úÖ Media initialized for $_userRole');
      
    } catch (e) {
      debugPrint('‚ùå Media initialization error: $e');
      // Don't throw - audience members should still connect even without media
      if (_userRole != 'audience') {
        throw Exception('Failed to access media devices: $e');
      }
    }
  }
  
  void _setupSocketListeners() {
    debugPrint('üéß Setting up socket listeners...');
    
    _socket!.on('connect', (_) {
      debugPrint('‚úÖ MediaSoup socket connected! ID: ${_socket!.id}');
    });
    
    _socket!.on('connecting', (_) {
      debugPrint('üîÑ Socket is connecting...');
    });
    
    _socket!.on('connect_error', (error) {
      debugPrint('‚ùå MediaSoup socket connection error: $error');
      debugPrint('‚ùå Error type: ${error.runtimeType}');
      debugPrint('‚ùå Socket ID during error: ${_socket!.id}');
      debugPrint('üí° Network troubleshooting:');
      debugPrint('   - Check if server 172.236.109.9:3005 is reachable');
      debugPrint('   - Verify firewall/network policies allow HTTP connections');
      debugPrint('   - Consider mobile network vs WiFi connectivity differences');
      onError?.call(error.toString());
    });
    
    _socket!.on('connect_timeout', (_) {
      debugPrint('‚è±Ô∏è Socket connection timeout!');
    });
    
    _socket!.on('error', (error) {
      debugPrint('‚ùå Socket error event: $error');
    });
    
    _socket!.on('disconnect', (_) {
      debugPrint('üîå MediaSoup socket disconnected');
      _handleDisconnection();
    });
    
    debugPrint('üéß Socket listeners set up complete');
    
    // MediaSoup-specific events
    _socket!.on('newProducer', (data) async {
      await _consumeProducer(data);
    });
    
    _socket!.on('producerClosed', (data) {
      _handleProducerClosed(data);
    });
    
    _socket!.on('peer-joined', (data) {
      final peerId = data['peerId'];
      final userId = data['userId'];
      final role = data['role'];
      debugPrint('üë§ Peer joined: $userId ($role) as $peerId');
      onPeerJoined?.call(peerId, userId, role);
    });
    
    _socket!.on('peer-left', (data) {
      final peerId = data['peerId'];
      debugPrint('üëã Peer left: $peerId');
      _cleanupPeer(peerId);
      onPeerLeft?.call(peerId);
    });
    
    // Role change events
    _socket!.on('role-changed', (data) {
      final userId = data['userId'];
      final newRole = data['newRole'];
      debugPrint('üîÑ User $userId role changed to: $newRole');
      
      // If it's our role that changed, update permissions
      if (userId == _userId) {
        _userRole = newRole;
        _canPublishMedia = _shouldPublishMedia(newRole, _currentRoomType ?? '');
        debugPrint('   Our role changed - canPublish: $_canPublishMedia');
        
        // Handle media based on new permissions
        if (_canPublishMedia && _localStream == null) {
          // TODO: Initialize media if promoted
        } else if (!_canPublishMedia && _localStream != null) {
          // Stop publishing if demoted
          _stopPublishing();
        }
        
        notifyListeners();
      }
    });
    
    // Screen share events
    _socket!.on('screen-share-started', (data) {
      final userId = data['userId'];
      debugPrint('üñ•Ô∏è User $userId started screen sharing');
      onRemoteScreenShareChanged?.call(userId, true);
    });
    
    _socket!.on('screen-share-stopped', (data) {
      final userId = data['userId'];
      debugPrint('üõë User $userId stopped screen sharing');
      onRemoteScreenShareChanged?.call(userId, false);
    });
  }
  
  Future<void> _consumeProducer(Map<String, dynamic> data) async {
    try {
      final producerId = data['producerId'];
      final peerId = data['peerId'];
      final userId = data['userId'];
      final role = data['role'];
      final kind = data['kind'];
      
      debugPrint('üéß Consuming $kind from $userId ($role)');
      
      // Don't consume own producers
      if (peerId == _myPeerId) return;
      
      // Only consume if we have a receive transport
      if (_recvTransport == null) {
        debugPrint('‚ö†Ô∏è No receive transport available');
        return;
      }
      
      final response = await _rpcRequest('consume', {
        'roomId': _currentRoom,
        'transportId': _recvTransport!.id,
        'producerId': producerId,
        'rtpCapabilities': _device!.rtpCapabilities.toMap(),
      });
      
      // Create consumer
      final mediaType = kind == 'audio' ? RTCRtpMediaType.RTCRtpMediaTypeAudio : RTCRtpMediaType.RTCRtpMediaTypeVideo;
      
      _recvTransport!.consume(
        id: response['id'],
        producerId: producerId,
        kind: mediaType,
        rtpParameters: RtpParameters.fromMap(response['rtpParameters']),
        peerId: peerId,
      );
      
      final consumerId = response['id'];
      
      // Resume consumer
      await _rpcRequest('resumeConsumer', {'consumerId': consumerId});
      
      // Create or get stream for this peer
      MediaStream? stream = _remoteStreams[peerId];
      if (stream == null) {
        stream = await createLocalMediaStream(peerId);
        _remoteStreams[peerId] = stream;
      }
      
      // Initialize video renderer if needed
      if (kind == 'video' && !_videoRenderers.containsKey(peerId)) {
        final renderer = RTCVideoRenderer();
        await renderer.initialize();
        renderer.srcObject = stream;
        _videoRenderers[peerId] = renderer;
      }
      
      onRemoteStream?.call(peerId, stream, userId, role);
      
      debugPrint('‚úÖ Consumer created for $userId ($role): $consumerId');
      
    } catch (e) {
      debugPrint('‚ùå Error consuming producer: $e');
    }
  }
  
  void _handleProducerClosed(Map<String, dynamic> data) {
    final producerId = data['producerId'];
    final peerId = data['peerId'];
    
    debugPrint('üõë Producer closed: $producerId from peer $peerId');
    
    // Find and close corresponding consumer
    _consumers.removeWhere((consumerId, consumer) {
      if (consumer.producerId == producerId) {
        consumer.close();
        return true;
      }
      return false;
    });
  }
  
  void _cleanupPeer(String peerId) {
    _remoteStreams.remove(peerId)?.dispose();
    _videoRenderers.remove(peerId)?.dispose();
    notifyListeners();
  }
  
  void _stopPublishing() {
    debugPrint('üõë Stopping media publishing');
    
    // Close all producers
    for (final producer in _producers.values) {
      producer.close();
    }
    _producers.clear();
    
    // Dispose local stream
    _localStream?.dispose();
    _localStream = null;
    
    // Close send transport
    _sendTransport?.close();
    _sendTransport = null;
  }
  
  Future<Map<String, dynamic>> _rpcRequest(String method, Map<String, dynamic> params) async {
    final completer = Completer<Map<String, dynamic>>();
    final requestId = DateTime.now().millisecondsSinceEpoch.toString();
    
    _socket!.once('response-$requestId', (response) {
      if (response['error'] != null) {
        completer.completeError(Exception(response['error']));
      } else {
        completer.complete(response);
      }
    });
    
    _socket!.emit('request', {
      'id': requestId,
      'method': method,
      'params': params,
    });
    
    return completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => throw TimeoutException('RPC request timeout: $method'),
    );
  }
  
  Future<void> _waitForConnection() async {
    final completer = Completer<void>();
    
    if (_socket!.connected) {
      completer.complete();
    } else {
      _socket!.once('connect', (_) => completer.complete());
      _socket!.once('connect_error', (error) => 
        completer.completeError(Exception('Connection error: $error')));
    }
    
    await completer.future.timeout(
      const Duration(seconds: 45),
      onTimeout: () => throw TimeoutException('Socket connection timeout after 45s - server may be unreachable from this network'),
    );
  }
  
  Future<void> toggleMute() async {
    // If we should be able to publish but don't have a stream, initialize it
    if (_canPublishMedia && _localStream == null) {
      debugPrint('üé§ Judge/Debater needs media stream - initializing...');
      await _initializeMedia(audioOnly: true);
      
      // If we have a send transport, produce tracks
      if (_sendTransport != null) {
        await _produceTracks();
      }
    }
    
    if (_localStream != null) {
      _isMuted = !_isMuted;
      for (final track in _localStream!.getAudioTracks()) {
        track.enabled = !_isMuted;
      }
      
      // Notify server of mute state
      _socket?.emit('mute-state-changed', {
        'roomId': _currentRoom,
        'userId': _userId,
        'isMuted': _isMuted,
      });
      
      debugPrint('üé§ Mute toggled: ${_isMuted ? "MUTED" : "UNMUTED"} (role: $_userRole)');
      notifyListeners();
    } else {
      debugPrint('‚ö†Ô∏è Cannot toggle mute - no local stream available (role: $_userRole, canPublish: $_canPublishMedia)');
    }
  }
  
  /// Force enable audio - useful for judges who need to speak
  Future<void> enableAudio() async {
    debugPrint('üé§ Force enabling audio for role: $_userRole');
    
    // Ensure we can publish
    if (!_canPublishMedia) {
      debugPrint('‚ö†Ô∏è Role $_userRole cannot publish media');
      return;
    }
    
    // Initialize media if not already done
    if (_localStream == null) {
      debugPrint('üé§ Initializing media stream for audio...');
      await _initializeMedia(audioOnly: true);
      
      // Create transport if needed
      if (_sendTransport == null && _device != null) {
        await _createSendTransport();
      }
      
      // Produce tracks if we have transport
      if (_sendTransport != null) {
        await _produceTracks();
      }
    }
    
    // Enable audio tracks
    if (_localStream != null) {
      _isMuted = false;
      for (final track in _localStream!.getAudioTracks()) {
        track.enabled = true;
      }
      
      // Notify server
      _socket?.emit('mute-state-changed', {
        'roomId': _currentRoom,
        'userId': _userId,
        'isMuted': false,
      });
      
      debugPrint('‚úÖ Audio force enabled for $_userRole');
      notifyListeners();
    }
  }
  
  /// Force disable audio
  Future<void> disableAudio() async {
    if (_localStream != null) {
      _isMuted = true;
      for (final track in _localStream!.getAudioTracks()) {
        track.enabled = false;
      }
      
      // Notify server
      _socket?.emit('mute-state-changed', {
        'roomId': _currentRoom,
        'userId': _userId,
        'isMuted': true,
      });
      
      debugPrint('üîá Audio force disabled for $_userRole');
      notifyListeners();
    }
  }
  
  Future<void> toggleLocalVideo() async {
    if (_localStream != null && _canPublishMedia) {
      _isVideoEnabled = !_isVideoEnabled;
      
      final videoTracks = _localStream!.getVideoTracks();
      for (final track in videoTracks) {
        track.enabled = _isVideoEnabled;
      }
      
      debugPrint('üé• Local video ${_isVideoEnabled ? 'enabled' : 'disabled'}');
      notifyListeners();
    }
  }
  
  /// Start screen sharing
  Future<void> startScreenShare() async {
    if (!_canPublishMedia) {
      debugPrint('‚ö†Ô∏è Cannot start screen share - role cannot publish');
      return;
    }
    
    try {
      debugPrint('üñ•Ô∏è Starting screen share...');
      
      // Get display media
      final Map<String, dynamic> mediaConstraints = {
        'video': {
          'width': {'ideal': 1920},
          'height': {'ideal': 1080},
          'frameRate': {'ideal': 30},
        },
        'audio': false, // No audio from screen share
      };
      
      await navigator.mediaDevices.getDisplayMedia(mediaConstraints);
      
      // TODO: Replace video track with screen share track in producer
      // This would require proper MediaSoup producer track replacement
      
      // Notify server and peers
      _socket?.emit('screen-share-started', {
        'roomId': _currentRoom,
        'userId': _userId,
      });
      
      debugPrint('‚úÖ Screen share started');
      
    } catch (e) {
      debugPrint('‚ùå Screen share error: $e');
      onError?.call('Failed to start screen share: $e');
    }
  }
  
  /// Stop screen sharing
  Future<void> stopScreenShare() async {
    try {
      debugPrint('üõë Stopping screen share...');
      
      // TODO: Restore original video track in producer
      
      // Notify server and peers
      _socket?.emit('screen-share-stopped', {
        'roomId': _currentRoom,
        'userId': _userId,
      });
      
      debugPrint('‚úÖ Screen share stopped');
      
    } catch (e) {
      debugPrint('‚ùå Stop screen share error: $e');
    }
  }
  
  /// Update user role (for role transitions)
  Future<void> updateRole(String newRole) async {
    if (_userRole == newRole) return;
    
    debugPrint('üîÑ Updating role from $_userRole to $newRole');
    final oldCanPublish = _canPublishMedia;
    _userRole = newRole;
    _canPublishMedia = _shouldPublishMedia(newRole, _currentRoomType ?? '');
    
    // Notify server of role change
    _socket?.emit('update-role', {
      'roomId': _currentRoom,
      'userId': _userId,
      'newRole': newRole,
    });
    
    // Handle media permissions change
    if (oldCanPublish != _canPublishMedia) {
      if (_canPublishMedia && _localStream == null) {
        // Initialize media if promoted
        await _initializeMedia(audioOnly: true);
        await _createSendTransport();
        await _produceTracks();
      } else if (!_canPublishMedia && _localStream != null) {
        // Stop publishing if demoted
        _stopPublishing();
      }
    }
    
    notifyListeners();
  }
  
  void _handleDisconnection() {
    _isConnected = false;
    
    // Clean up MediaSoup objects
    for (final producer in _producers.values) {
      producer.close();
    }
    _producers.clear();
    
    for (final consumer in _consumers.values) {
      consumer.close();
    }
    _consumers.clear();
    
    _sendTransport?.close();
    _recvTransport?.close();
    _sendTransport = null;
    _recvTransport = null;
    
    // Clean up media
    _localStream?.dispose();
    _localStream = null;
    _remoteStreams.clear();
    for (final renderer in _videoRenderers.values) {
      renderer.dispose();
    }
    _videoRenderers.clear();
    
    onDisconnected?.call();
    notifyListeners();
  }
  
  Future<void> _forceDisconnect() async {
    if (_isDisposed) return;
    
    if (_socket != null) {
      _socket!.emit('leave-room', {'roomId': _currentRoom});
      _socket!.disconnect();
      _socket!.clearListeners();
      _socket = null;
    }
    
    _handleDisconnection();
    
    // Reset state
    _currentRoom = null;
    _currentRoomType = null;
    _userRole = null;
    _userId = null;
    _myPeerId = null;
    _routerRtpCapabilities = null;
    _isConnected = false;
    _isMuted = false;
    _isVideoEnabled = false;
    _canPublishMedia = false;
  }
  
  Future<void> disconnect() async {
    if (_isDisposed) return;
    await _forceDisconnect();
    notifyListeners();
  }
  
  @override
  void dispose() {
    _isDisposed = true;
    disconnect();
    super.dispose();
  }
}